<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[重学前端]]></title>
    <url>%2Farchives%2Ffront-end%2F1555989538.html</url>
    <content type="text"><![CDATA[最近有在学习 winter 老师的重学前端课程整理，打算根据课程的内容整理一下自己的前端知识体系，总的来说还是下面的标题进行梳理。 JavaScript: 按照文法、语义和运行时去讨论 JavaScript 语言。即“用一定的词法和语法，表达一定语义，去操作运行时”。 HTML 和 CSS: HTML 的功能主要由标签来承担，所以我们首先会把标签分类，并分别进行讲解。语言部分，我们会简要介绍 HTML 的语法和几个重要的语言机制。在 CSS 的语言部分，我们会从大到小介绍 @rule、选择器、单位等等。功能部分，我们大致可以分为布局、绘制和交互类。 浏览器的实现原理与 API: 一个浏览器到底是如何工作的。并且，我们还会学习一些重要的浏览器 API，包括 BOM、DOM、CSSOM 等内容。只有了解了这些知识，你才能把 JavaScript 和 HTML、CSS 联系起来实现具体功能。 前端工程实践: 前端的性能、工具链、持续集成、架构等实际应用内容。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>重学前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程实践]]></title>
    <url>%2Farchives%2Ffront-end%2FEngineering-Practice%2F1555988596.html</url>
    <content type="text"><![CDATA[性能 对于任何一个前端团队而言，性能都是它价值的核心指标，但性能并非细节的堆砌，也不是默默优化，我们应当从团队角度来探讨性能的方法论和技术体系。 工具链 对一个高效又合作良好的前端团队来说，一致性的工具链是不或缺的保障，作为开发阶段的入口，工具链又可以和性能、发布、持续集成等系统链接到一起，成为团队技术管理的基础。 持续集成 过去持续集成概念和理论都针对软件开发，而对于前端来说，持续集成是一个新课题（对于持续集成来说，前端也是一个新课题）。 搭建系统 前段工作往往多而繁杂，针对高重复性、可模块化的业务需求，传统的人工开发不在适用，搭建系统是大部分前端团队的选择。 架构与基础库 前端构架的主要职责是兼容性、复用和能力拓展。]]></content>
      <categories>
        <category>前端</category>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>重学前端</tag>
        <tag>持续集成</tag>
        <tag>部署</tag>
        <tag>Web开发</tag>
        <tag>框架</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 整理]]></title>
    <url>%2Farchives%2Ffront-end%2FJavaScript%2F1555988415.html</url>
    <content type="text"><![CDATA[在 JavaScript 的模块中,首先我们可以把语言按照文法、语义和运行时来拆分,这符合编程语言的一般规律: 用一定的词法和语句,表达一定语句,从而操作运行时。 语义 文法 词法 语法 运行时 按照程序的一般规律,把运行时分为数据结构和算法部分: 数据结构包含类型和实例(JavaScript 的类型系统就是它的 7 种基本类型和 7 种语言类型,实例就是它的内置对象部分)。所谓算法就是 JavaScript 的执行过程。 数据结构 类型 JavaScript 的 7 种语言类型,包括 6 种原始数据类型和 Object Undefined 含义: 尚未赋值的变量的值undefined 取值: undefined (也可以通过void 0得到) Null 含义: 表示变量值为null 取值: null Boolean 含义: Boolean表示逻辑意义上的真或假 取值: true, false String 含义: String表示文本数据 (采用 UTF16 编码, 处理非 BMP 的字符符需要格外小心) 取值: 最大长度为2^53-1 Note: 现行的字符集国际标准,字符是以 Unicode 的方式表示的,每一个 Unicode 的码点表示一个字符,理论上,Unicode 的范围是无限的。UTF 是 Unicode 的编码方式,规定了码点在计算机中的表示方法,常见的有 UTF16 和 UTF8。 Unicode 的码点通常用 U+??? 来表示,其中 ??? 是十六进制的码点值。 0-65536(U+0000 - U+FFFF)的码点被称为基本字符区域(BMP)。 Number 含义: Number表示数字 (Number 是双精度 64 位浮点格式(IEEE 754)中的数字数据类型) 取值: 取值范围 [-(2^53 -1) , 2^53 -1] Symbol (new in ECMAScript 6) 含义: Symbol是一个唯一的不可变的原始值 取值: 使用全局的Symbol函数创建 (不可以使用 new 创建 Symbol 对象, Symbol 值不能进行运算) Object 含义: Object可以看做属性的集合 Object 属性主要分成两类 (通常用于定义属性的代码会产生数据属性,其中的 writable、enumerable、configurable 都默认为 true。 JavaScript 的 7 种规范类型 List 和 Record: 用于描述函数传参过程。 Set: 主要用于解释字符集等。 Completion Record: 用于描述异常、跳出等语句执行过程。 Reference: 用于描述对象属性访问、delete 等。 Property Descriptor: 用于描述对象的属性。 Lexical Environment 和 Environment Record: 用于描述变量和作用域。 Data Block: 用于描述二进制数据。 Object 对象 JavaScript 对象是键和值之间的映射。 Properties 属性 使用对象文字语法,初始化一组有限的属性;然后可以添加和删除属性。 属性值可以是任何类型的值,包括其他对象,这使得能够构建复杂的数据结构。使用键值标识属性。键值是String或Symbol值。 Object 属性主要分成两类: 数据属性和访问器属性。 数据属性: 大多数时候我们只关心数据属性的值 value: 就是属性的值 writable: 决定属性能否被赋值 enumerable: 决定 for in 能否枚举该属性 configurable: 决定该属性能否被删除或者改变特征值 访问器属性: 每次访问属性,都会执行 getter 或者 setter 函数 getter: 函数或 undefined,在取属性值时被调用 setter: 函数或 undefined,在设置属性值时被调用 enumerable: 决定 for in 能否枚举该属性 configurable: 决定该属性能否被删除或者改变特征值 我们可以使用内置函数 Object.getOwnPropertyDescriptor(obj, prop) 来查看;也可以使用Object.defineProperty(obj, prop, descriptor) 来定义属性。 实例 JavaScript 的实例对象主要分成宿主对象和内置对象两个部分 宿主对象(host Objects): 由 JavaScript 宿主环境提供的对象,它们的行为完全由宿主环境决定。(宿主对象也分为固有的和用户可创建的两种,比如 document.createElement 就可以创建一些 dom 对象。) 内置对象(Built-in Objects): 由 JavaScript 语言提供的对象。 固有对象(Intrinsic Objects): 由标准规定,随着 JavaScript 运行时创建而自动创建的对象实例。 原生对象(Native Objects): 可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。 基本类型 基础功能和数据结构 错误类型 二进制操作 带类型的数组 Boolean Array Error ArrayBuffer Float32Array String Date EvalError SharedArrayBuffer Float64Array Number RegExp RangeError DataView Int8Array Symbol Promise ReferenceError Int16Array Object Proxy SyntaxError Int32Array Map TypeError UInt8Array WeakMap URIError UInt16Array Set UInt32Array WeakSet UInt8ClampendArray Function 普通对象(Ordinary Objects): 由{}语法、Object 构造器或者 class 关键字定义类创建的对象,它能够被原型继承。 应用和机制 执行过程(算法) 如果我们是浏览器或者 Node 的开发者，我们该如何使用 JavaScript 引擎。 当拿到一段 JavaScript 代码时，浏览器或者 Node 环境首先要做的就是；传递给 JavaScript 引擎，并且要求它去执行。 然而，执行 JavaScript 并非一锤子买卖，宿主环境当遇到一些事件时，会继续把一段代码传递给 JavaScript 引擎去执行，此外，我们可能还会提供 API 给 JavaScript 引擎，比如 setTimeout 这样的 API，它会允许 JavaScript 在特定的时机执行。 所以，我们首先应该形成一个感性的认知: 一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。 在 ES3 和更早的版本中，JavaScript 本身还没有异步执行代码的能力，这也就意味着，宿主环境传递给 JavaScript 引擎一段代码，引擎就把代码直接顺次执行了，这个任务也就是宿主发起的任务。 但是，在 ES5 之后，JavaScript 引入了 Promise，这样，不需要浏览器的安排，JavaScript 引擎本身也可以发起任务了。 由于我们这里主要讲 JavaScript 语言，那么采纳 JSC 引擎的术语，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。 事件循环 JavaScript 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把这个部分称为事件循环。 不过，术语本身并非我们需要重点讨论的内容，我们在这里把重点放在事件循环的原理上。在底层的 C/C++ 代码中，这个事件循环是一个跑在独立线程中的循环，我们用伪代码来表示，大概是这样的: 1234while(TRUE) &#123; r = wait(); execute(r);&#125; 我们可以看到，整个循环做的事情基本上就是反复“等待 - 执行”。当然，实际的代码中并没有这么简单，还有要判断循环是否结束、宏观任务队列等逻辑，这里为了方便你理解，我就把这些都省略掉了。 这里每次的执行过程，其实都是一个宏观任务。我们可以大概理解: 宏观任务的队列就相当于事件循环。 在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列: 有了宏观任务和微观任务机制，我们就可以实现 JS 引擎级和宿主级的任务了，例如: Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。 微任务的执行 Promise Promise 是 JavaScript 语言提供的一种标准化的异步管理方式，它的总体思想是，需要进行 io、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（通过 Promise 的 then 方法的回调）。 Promise 产生的是 JavaScript 引擎内部的微任务，而 setTimeout 是浏览器 API，它产生宏任务。 async/await async/await 是 ES2016 新加入的特性，它提供了用 for、if 等代码结构来编写异步的方式。它的运行时基础是 Promise，面对这种比较新的特性，我们先来看一下基本用法。 async 函数必定返回 Promise，我们把所有返回 Promise 的函数都可以认为是异步函数。 async 函数是一种特殊语法，特征是在 function 关键字之前加上 async 关键字，这样，就定义了一个 async 函数，我们可以在其中使用 await 来等待一个 Promise。 generator/iterator 也常常被跟异步一起来讲，我们必须说明 generator/iterator 并非异步代码，只是在缺少 async/await 的时候，一些框架（最著名的要数 co）使用这样的特性来模拟 async/await。 但是 generator 并非被设计成实现异步，所以有了 async/await 之后，generator/iterator 来模拟异步的方法应该被废弃。 函数的执行 闭包: closure 环境部分 环境 变量环境 词法环境 标识符列表 λ 表达式 JavaScript 函数 环境部分 词法作用域: 执行上下文的一部分 scope this 值 函数里面不带 var/let/const 的变量 函数 闭包 编译原理中，它是处理语法产生式的一个步骤 计算几何中，它表示包裹平面点集的凸多边形（翻译作凸包） 而在编程语言领域，它表示一种函数 闭包这个概念第一次出现在 1964 年的《The Computer Journal》上，由 P. J. Landin 在《The mechanical evaluation of expressions》一文中提出了 applicative expression 和 closure 的概念。 在上世纪 60 年代，主流的编程语言是基于 lambda 演算的函数式编程语言，所以这个最初的闭包定义，使用了大量的函数式术语。一个不太精确的描述是“带有一系列信息的 λ 表达式”。对函数式语言而言，λ 表达式其实就是函数。 我们可以这样简单理解一下，闭包其实只是一个绑定了执行环境的函数，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数的区别是，它携带了执行的环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。 这个古典的闭包定义中，闭包包含两个部分。 环境部分 环境 标识符列表 表达式部分 当我们把视角放在 JavaScript 的标准中，我们发现，标准中并没有出现过 closure 这个术语，但是，我们却不难根据古典定义，在 JavaScript 中找到对应的闭包组成部分。 环境部分 环境: 函数的词法环境（执行上下文的一部分） 标识符列表: 函数中用到的未声明的变量 表达式部分: 函数体 至此，我们可以认为，JavaScript 中的函数完全符合闭包的定义。它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，它的表达式部分就是函数体。 这里我们容易产生一个常见的概念误区，有些人会把 JavaScript 执行上下文，或者作用域（Scope，ES3 中规定的执行上下文的一部分）这个概念当作闭包。 实际上 JavaScript 中跟闭包对应的概念就是“函数”，可能是这个概念太过于普通，跟闭包看起来又没什么联系，所以大家才不自觉地把这个概念对应到了看起来更特别的“作用域”吧。 执行上下文: 执行的基础设施 相比普通函数，JavaScript 函数的主要复杂性来自于它携带的“环境部分”。当然，发展到今天的 JavaScript，它所定义的环境部分，已经比当初经典的定义复杂了很多。 JavaScript 中与闭包“环境部分”相对应的术语是“词法环境”，但是 JavaScript 函数比 λ 函数要复杂得多，我们还要处理 this、变量声明、with 等等一系列的复杂语法，λ 函数中可没有这些东西，所以，在 JavaScript 的设计中，词法环境只是 JavaScript 执行上下文的一部分。 JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为: “执行上下文”。 执行上下文在 ES3 中，包含三个部分。 scope: 作用域，也常常被叫做作用域链。 variable object: 变量对象，用于存储变量的对象。 this value: this 值。 在 ES5 中，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子。 lexical environment: 词法环境，当获取变量时使用。 variable environment: 变量环境，当声明变量时使用。 this value: this 值。 在 ES2018 中，执行上下文又变成了这个样子，this 值被归入 lexical environment，但是增加了不少内容。 lexical environment: 词法环境，当获取变量或者 this 值时使用。 variable environment: 变量环境，当声明变量时使用 code evaluation state: 用于恢复代码执行位置。 Function: 执行的任务是函数时使用，表示正在被执行的函数。 ScriptOrModule: 执行的任务是脚本或者模块时使用，表示正在被执行的代码。 Realm: 使用的基础库和内置对象实例。 Generator: 仅生成器上下文有这个属性，表示当前生成器。 Realm 在最新的标准（9.0）中，JavaScript 引入了一个新概念 Realm，它的中文意思是“国度”“领域”“范围”。在 ES2016 之前的版本中，标准中甚少提及{}的原型问题。但在实际的前端开发中，通过 iframe 等方式创建多 window 环境并非罕见的操作，所以，这才促成了新概念 Realm 的引入。 Realm 中包含一组完整的内置对象，而且是复制关系。 对不同 Realm 中的对象操作，会有一些需要格外注意的问题，比如 typeof、instanceOf 几乎是失效的。 以下代码展示了在浏览器环境中获取来自两个 Realm 的对象，它们跟本土的 Object 做 instanceOf 时会产生差异: 12345678910var iframe = document.createElement('iframe')document.documentElement.appendChild(iframe)iframe.src="javascript:var b = &#123;&#125;;"var b1 = iframe.contentWindow.b;var b2 = &#123;&#125;;console.log(typeof b1, typeof b2); //undefined objectconsole.log(b1 instanceof Object, b2 instanceof Object); //false true 函数的种类 普通函数: 用 function 关键字定义的函数 箭头函数: 用 =&gt; 运算符定义的函数 方法: 在 class 中定义的函数 生成器函数: 用 function * 定义的函数 123function* foo() &#123; // code&#125; 类: 用 class 定义的类，实际上也是函数 异步函数: 普通函数、箭头函数和生成器函数加上 async 关键字 123456789async function foo()&#123; // code&#125;const foo = async () =&gt; &#123; // code&#125;async function foo*()&#123; // code&#125; this 关键字的行为 this 是 JavaScript 中的一个关键字，它的使用方法类似于一个变量（但是 this 跟变量的行为有很多不同，上一节课我们讲了一些普通变量的行为和机制，也就是 var 声明和赋值、let 的内容）。 this 是执行上下文中很重要的一个组成部分。同一个函数调用方式不同，得到的 this 值也不同。 调用函数时使用的引用，决定了函数执行时刻的 this 值。 箭头函数的调用方式，不会影响它的 this 值。 生成器函数、异步生成器函数和异步普通函数跟普通函数行为是一致的，异步箭头函数与箭头函数行为是一致的。 this 关键字的机制 函数能够引用定义时的变量，如上文分析，函数也能记住定义时的 this，因此，函数内部必定有一个机制来保存这些信息。 在 JavaScript 标准中，为函数规定了用来保存定义时上下文的私有属性 [[Environment]]。 当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的 [[Environment]]。 这个动作就是切换上下文了，我们假设有这样的代码: 12345678910var a = 1;foo();在别处定义了 foo:var b = 2;function foo()&#123; console.log(b); // 2 console.log(a); // error&#125; 这里的 foo 能够访问 b（定义时词法环境），却不能访问 a（执行时的词法环境），这就是执行上下文的切换机制了。 JavaScript 用一个栈来管理执行上下文，这个栈中的每一项又包含一个链表。如下图所示: 当函数调用时，会入栈一个新的执行上下文，函数调用结束时，执行上下文被出栈。 而 this 则是一个更为复杂的机制，JavaScript 标准定义了 [[thisMode]] 私有属性。 [[thisMode]] 私有属性有三个取值。 lexical: 表示从上下文中找 this，这对应了箭头函数。 global: 表示当 this 为 undefined 时，取全局对象，对应了普通函数。 strict: 当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined。 非常有意思的是，方法的行为跟普通函数有差异，恰恰是因为 class 设计成了默认按 strict 模式执行。 我们可以用 strict 达成与上一节中方法的例子一样的效果: 1234567891011'use strict';function showThis() &#123; console.log(this);&#125;var o = &#123; showThis: showThis,&#125;;showThis(); // undefinedo.showThis(); // o 函数创建新的执行上下文中的词法环境记录时，会根据 [[thisMode]] 来标记新纪录的 [[ThisBindingStatus]] 私有属性。 代码执行遇到 this 时，会逐层检查当前词法环境记录中的 [[ThisBindingStatus]]，当找到有 this 的环境记录时获取 this 的值。 这样的规则的实际效果是，嵌套的箭头函数中的代码都指向外层 this，例如: 12345678910var o = &#123;&#125;;o.foo = function foo() &#123; console.log(this); return () =&gt; &#123; console.log(this); return () =&gt; console.log(this); &#125;;&#125;;o.foo()()(); // o, o, o 这个例子中，我们定义了三层嵌套的函数，最外层为普通函数，两层都是箭头函数。 这里调用三个函数，获得的 this 值是一致的，都是对象 o。 操作 this 的内置函数 Function.prototype.call 和 Function.prototype.apply 可以指定函数调用时传入的 this 值，示例如下: 123456function foo(a, b, c) &#123; console.log(this); console.log(a, b, c);&#125;foo.call(&#123;&#125;, 1, 2, 3);foo.apply(&#123;&#125;, [1, 2, 3]); 这里 call 和 apply 作用是一样的，只是传参方式有区别。 此外，还有 Function.prototype.bind 它可以生成一个绑定过的函数，这个函数的 this 值固定了参数: 12345function foo(a, b, c) &#123; console.log(this); console.log(a, b, c);&#125;foo.bind(&#123;&#125;, 1, 2, 3)(); 有趣的是，call、bind 和 apply 用于不接受 this 的函数类型如箭头、class 都不会报错。 这时候，它们无法实现改变 this 的能力，但是可以实现传参。 new 与 this new 的执行过程 以构造器的 prototype 属性（注意与私有字段 [[prototype]] 的区分）为原型，创建新对象； 将 this 和调用参数传给构造器，执行； 如果构造器返回的是对象，则返回，否则返回第一步创建的对象。 new 和函数的对应关系 仅普通函数和类能够跟 new 搭配使用 函数类型 new 普通函数 新对象 箭头函数 报错 方法 报错 生成器 报错 类 新对象 异步普通函数 报错 异步箭头函数 报错 异步生成器函数 报错 语句级的执行 JavaScript 语句执行机制涉及的一种基础类型: Completion 类型 JavaScript 语句执行的完成状态，我们用一个标准类型来表示: Completion Record Completion Record 表示一个语句执行完之后的结果，它有三个字段: [[type]] 表示完成的类型，有 break continue return throw 和 normal 几种类型； [[value]] 表示语句的返回值，如果语句没有，则是 empty； [[target]] 表示语句的目标，通常是一个 JavaScript 标签（标签在后文会有介绍）。 JavaScript 正是依靠语句的 Completion Record 类型，方才可以在语句的复杂嵌套结构中，实现各种控制。 普通语句 声明类语句 var 声明 在只有 var，没有 let 的旧 JavaScript 时代，诞生了一个技巧，叫做: 立即执行的函数表达式（IIFE），通过创建一个函数，并且立即执行，来构造一个新的域，从而控制 var 的范围。 由于语法规定了 function 关键字开头是函数声明，所以要想让函数变成函数表达式，我们必须得加点东西，最常见的做法是加括号。 12345678910&gt; (function()&#123;&gt; var a;&gt; //code&gt; &#125;());&gt;&gt; (function()&#123;&gt; var a;&gt; //code&gt; &#125;)();&gt; 但是，括号有个缺点，那就是如果上一行代码不写分号，括号会被解释为上一行代码最末的函数调用，产生完全不符合预期，并且难以调试的行为，加号等运算符也有类似的问题。所以一些推荐不加分号的代码风格规范，会要求在括号前面加上分号。 12345678910&gt; ;(function()&#123;&gt; var a;&gt; //code&gt; &#125;())&gt;&gt; ;(function()&#123;&gt; var a;&gt; //code&gt; &#125;)()&gt; 我比较推荐的写法是使用 void 关键字。也就是下面的这种形式。 12345&gt; void function()&#123;&gt; var a;&gt; //code&gt; &#125;();&gt; 这有效避免了语法问题，同时，语义上 void 运算表示忽略后面表达式的值，变成 undefined，我们确实不关心 IIFE 的返回值，所以语义也更为合理。 123456789101112&gt; var b;&gt; void function()&#123;&gt; var env = &#123;b:1&#125;;&gt; b = 2;&gt; console.log("In function b:", b);&gt; with(env) &#123;&gt; var b = 3;&gt; console.log("In with b:", b);&gt; &#125;&gt; &#125;();&gt; console.log("Global b:", b);&gt; const 声明 let 声明 let 是 ES6 开始引入的新的变量声明模式，比起 var 的诸多弊病，let 做了非常明确的梳理和规定。 为了实现 let，JavaScript 在运行时引入了块级作用域。也就是说，在 let 出现之前，JavaScript 的 if for 等语句皆不产生作用域。 函数声明 类声明 表达式语句 空语句 with 语句 debugger 语句 普通语句执行后，会得到 [[type]] 为 normal 的 Completion Record，JavaScript 引擎遇到这样的 Completion Record，会继续执行下一条语句。 这些语句中，只有表达式语句会产生 [[value]]，当然，从引擎控制的角度，这个 value 并没有什么用处。 如果你经常使用 chrome 自带的调试工具，可以知道，输入一个表达式，在控制台可以得到结果，但是在前面加上 var，就变成了 undefined。 Chrome 控制台显示的正是语句的 Completion Record 的 [[value]]。 语句块 大括号括起来的一组语句，它是一种语句的复合结构，可以嵌套。 语句块本身并不复杂，我们需要注意的是语句块内部的语句的 Completion Record 的 [[type]] 如果不为 normal，会打断语句块后续的语句执行。 比如我们考虑，一个 [[type]] 为 return 的语句，出现在一个语句块中的情况。 从语句的这个 type 中，我们大概可以猜到它由哪些特定语句产生，我们就来说说最开始的例子中的 return。 return 语句可能产生 return 或者 throw 类型的 Completion Record。我们来看一个例子。 先给出一个内部为普通语句的语句块: 12345&#123; var i = 1; // normal, empty, empty i++; // normal, 1, empty console.log(i); //normal, undefined, empty&#125; // normal, undefined, empty 在每一行的注释中，都给出了语句的 Completion Record 值。 我们看到，在一个 block 中，如果每一个语句都是 normal 类型，那么它会顺次执行。接下来我们加入 return 试试看。 123456&#123; var i = 1; // normal, empty, empty return i; // return, 1, empty i++; console.log(i);&#125; // return, 1, empty 但是假如我们在 block 中插入了一条 return 语句，产生了一个非 normal 记录，那么整个 block 会成为非 normal。这个结构就保证了非 normal 的完成类型可以穿透复杂的语句嵌套结构，产生控制效果。 控制型语句 if switch for for for…of for-await-of for…in while while do-while continue break return throw try 控制型语句带有 if、switch 关键字，它们会对不同类型的 Completion Record 产生反应。 控制类语句分成两部分，一类是对其内部造成影响，如 if、switch、while/for、try。另一类是对外部造成影响如 break、continue、return、throw，这两类语句的配合，会产生控制代码执行顺序和执行逻辑的效果，这也是我们编程的主要工作。 一般来说， for/while - break/continue 和 try - throw 这样比较符合逻辑的组合，是大家比较熟悉的，但是，实际上，我们需要控制语句跟 break 、continue 、return 、throw 四种类型与控制语句两两组合产生的效果。 break continue return throw if 穿透 穿透 穿透 穿透 switch 消费 穿透 穿透 穿透 for/while 消费 消费 穿透 穿透 function 报错 报错 消费 穿透 try 特殊处理 特殊处理 特殊处理 消费 catch 特殊处理 特殊处理 特殊处理 穿透 finally 特殊处理 特殊处理 特殊处理 穿透 因为 finally 中的内容必须保证执行，所以 try/catch 执行完毕，即使得到的结果是非 normal 型的完成记录，也必须要执行 finally。 而当 finally 执行也得到了非 normal 记录，则会使 finally 中的记录作为整个 try 结构的结果。 带标签的语句 任何 JavaScript 语句是可以加标签的，在语句前加冒号即可。 大部分时候，这个东西类似于注释，没有任何用处。唯一有作用的时候是: 与完成记录类型中的 target 相配合，用于跳出多层循环。 123456outer: while (true) &#123; inner: while (true) &#123; break outer; &#125;&#125;console.log('finished'); break/continue 语句如果后跟了关键字，会产生带 target 的完成记录。一旦完成记录带了 target，那么只有拥有对应 label 的循环语句会消费它。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>重学前端</tag>
        <tag>JavaScript</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 整理]]></title>
    <url>%2Farchives%2Ffront-end%2FCSS%2F1555987337.html</url>
    <content type="text"><![CDATA[同样也是按照语言和功能来划分，语言部分从大到小有各种语法结构，比如@rule、选择器、单位等等；功能的部分大致可以分为布局、绘制和交互类。 在布局类我们常用的布局有: 正常流和弹性布局；绘制类则分成图形相关和文字相关的绘制；最后则是动画和其他的交互。 语法 @rule 规则 @charset 用于提示 CSS 文件使用的字符编码方式，它如果被使用，必须出现在最前面。这个规则只在给出语法解析阶段前使用，并不影响页面上的展示效果。 1@charset "utf-8"; @import 用于引入一个 CSS 文件，除了 @charset 规则不会被引入，@import 可以引入另一个文件的全部内容。(支持 supports 和 media query 形式) 123456 @import "mystyle.css"; @import url("mystyle.css");--- @import [ &lt;url&gt; | &lt;string&gt; ] [ supports( [ &lt;supports-condition&gt; | &lt;declaration&gt; ] ) ]? &lt;media-query-list&gt;? ; @media media query 使用的规则，它能够对设备的类型进行一些判断。在 media 的区块内，是普通规则列表。 12345@media print &#123; body &#123; font-size: 10pt; &#125;&#125; @page 用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。 1234567891011@page &#123; size: 8.5in 11in; margin: 10%; @top-left &#123; content: 'Hamlet'; &#125; @top-right &#123; content: 'Page ' counter(page); &#125;&#125; @counter-style 产生一种数据，用于定义列表项的表现。 12345@counter-style triangle &#123; system: cyclic; symbols: ‣; suffix: ' ';&#125; @keyframes 产生一种数据，用于定义动画关键帧。 12345678910@keyframes diagonal-slide &#123; from &#123; left: 0; top: 0; &#125; to &#123; left: 100px; top: 100px; &#125;&#125; @fontface 用于定义一种字体，icon font 技术就是利用这个特性来实现的。 12345678@font-face &#123; font-family: Gentium; src: url(http://example.com/fonts/Gentium.woff);&#125;p &#123; font-family: Gentium, serif;&#125; @supports 检查环境的特性，它与 media 比较类似。 @namespace 用于跟 XML 命名空间配合的一个规则，表示内部的 CSS 选择器全都带上特定命名空间。 @viewport 用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被 html 的 meta 代替。 其他 (不太推荐) @color-profile 是 SVG1.0 引入的 CSS 特性，但是实现状况不怎么好。 @document 还没讨论清楚，被推迟到了 CSS4 中。 @font-feature-values 。todo 查一下。 普通规则 关键词索引: https://developer.mozilla.org/en-US/docs/Web/CSS/Reference#Keyword_index 选择器 complex-selector 选择符 combinator 空格: 后代选择器 选中所有子节点及其所有后代节点 &gt;: 子元素选择器 选中子节点 +: 相邻兄弟选择器 选中下一个相邻节点 ~: 后续兄弟选择器 选中之后所有的相邻节点 ||: 列组选择器 Column combinator (实验内容) 选择表格的一列 复合选择器 compound-selector 类型选择器 type-selector 子选择器 subclass-selector id class 属性 attribute 伪类 pseudo-class 伪元素 pseudo-element 声明: 属性和值 声明部分是一个由“属性: 值”组成的序列。 属性 是由中划线、下划线、字母等组成的标识符，CSS 还支持使用反斜杠转义。我们需要注意的是: 属性不允许使用连续的两个中划线开头，这样的属性会被认为是 CSS 变量。 在CSS Variables 标准中，以双中划线开头的属性被当作变量，与之配合的则是 var 函数: 12345678:root &#123; --main-color: #06c; --accent-color: #006;&#125;/* The rest of the CSS file */#foo h1 &#123; color: var(--main-color);&#125; 值 的部分，主要在标准 CSS Values and Unit，根据每个 CSS 属性可以取到不同的值，这里的值可能是字符串、标识符。 CSS 属性值可能是以下类型。 CSS 范围的关键字: initial，unset，inherit，任何属性都可以的关键字。 字符串: 比如 content 属性。 URL: 使用 url() 函数的 URL 值。 整数 / 实数: 比如 flex 属性。 维度: 单位的整数 / 实数，比如 width 属性。 百分比: 大部分维度都支持。 颜色: 比如 background-color 属性。 图片: 比如 background-image 属性。 2D 位置: 比如 background-position 属性。 函数: 来自函数的值，比如 transform 属性。 CSS 支持一批特定的计算型函数: calc() 函数是基本的表达式计算，它支持加减乘除四则运算。在针对维度进行计算时，calc() 函数允许不同单位混合运算，这非常的有用。 max() 表示取两数中较大的一个 min() 表示取两数之中较小的一个 clamp() 给一个值限定一个范围，超出范围外则使用范围的最大或者最小值 toggle() (不建议使用，在任何浏览器中都不生效)函数在规则选中多于一个元素时生效，它会在几个值之间来回切换，比如我们要让一个列表项的样式圆点和方点间隔出现，可以使用下面代码: 123ul &#123; list-style-type: toggle(circle, square);&#125; attr() 函数允许 CSS 接受属性值的控制。 功能 布局 正常流 浏览器最基本的排版方案是正常流排版，它包含了顺次排布和折行等规则，这是一个跟我们提到的印刷排版类似的排版方案，也跟我们平时书写文字的方式一致，所以我们把它叫做正常流。 浏览器可以支持元素和文字的混排，元素被定义为占据长方形的区域，还允许边框、边距和留白，这个就是所谓的盒模型 在正常流的基础上，浏览器还支持两类元素: 绝对定位元素和浮动元素。 绝对定位元素把自身从正常流抽出，直接由 top 和 left 等属性确定自身的位置，不参加排版计算，也不影响其它元素。绝对定位元素由 position 属性控制。 浮动元素则是使得自己在正常流的位置向左或者向右移动到边界，并且占据一块排版空间。浮动元素由 float 属性控制。 弹性布局 flex 栅格布局 grid 绘制 颜色和形状 文字相关 交互 动画 其他交互]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>重学前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 整理]]></title>
    <url>%2Farchives%2Ffront-end%2FHTML%2F1555987336.html</url>
    <content type="text"><![CDATA[HTML 可以按照功能和语言来划分它的知识，HTML 的知识主要由标签来承担，所以我们首先会把标签做一些分类。诸如 title、meta、style、link、base 这些，它们用来描述文档的一些基本信息。还有一类是诸如 section、nav 的标签，它们在视觉表现上跟 div 没有区别，但是各有各的适用场景，我们把它们称作是语义类标签。另外一类是 img、video、audio 之类的替换型媒体类标签，用来引入外部内容，平常开发中也很常用。再有就是表单类的，比如 input、button。 元素 文档元信息 通常是出现在 head 标签中的元素，包括了描述文档自身的一些信息 title: 文档标题。 base: 页面的基准 URL: 历史遗留标签。它的作用是给页面上所有的 URL 相对地址提供一个基础。base 标签最多只有一个，它改变全局的链接地址，它是一个非常危险的标签。 meta: 元信息通用标签: 是一组键值对，是一种通用的元信息表示标签。一般由 name(表示元信息的名)和 content(则用于表示元信息的值)两个属性来定义。 12&lt;meta name="application-name" content="lsForums" /&gt;&lt;!-- meta 标签可以被自由定义，只要写入和读取的双方约定好 name 和 content 的格式就可以 --&gt; 具有 charset 属性的 meta: 描述了 HTML 文档自身的编码形式 12&lt;meta charset="UTF-8" /&gt;&lt;!-- 浏览器读到这个标签之前，处理的所有字符都是 ASCII 字符，因此建议这个标签放在 head 的第一个。 --&gt; 具有 http-equiv 属性的 meta: 表示执行一个命令，这样的 meta 标签可以不需要 name 属性了。 12&lt;meta http-equiv="content-type" content="text/html; charset=UTF-8" /&gt;&lt;!-- 相当于添加了 content-type 这个 http 头，并且指定了 http 编码方式。 --&gt; cache-control: 缓存请求指令 1234567Cache-Control: max-age=&lt;seconds&gt;Cache-Control: max-stale[=&lt;seconds&gt;]Cache-Control: min-fresh=&lt;seconds&gt;Cache-control: no-cacheCache-control: no-storeCache-control: no-transformCache-control: only-if-cached content-type: 指定 http 编码方式 content-language: 指定内容的语言 default-style: 指定默认样式表 refresh: 刷新 set-cookie: 模拟 http 头 set-cookie，设置 cookie x-ua-compatible: 模拟 http 头 x-ua-compatible，指定文件兼容性模式 content-security-policy: 模拟 http 头 content-security-policy，声明内容安全策略 name 为 viewport 的 meta: 没有在 HTML 标准中定义，却是移动端开发的事实标准: 它就是 name 为 viewport 的 meta。 12345&lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/&gt;&lt;!-- 这类 meta 的 name 属性为 viewport，它的 content 是一个复杂结构，是用逗号分隔的键值对，键值对的格式是 key=value。 --&gt; width: 页面宽度，可以取值具体的数字，也可以是 device-width，表示跟设备宽度相等。 height: 页面高度，可以取值具体的数字，也可以是 device-height，表示跟设备高度相等。 initial-scale: 初始缩放比例。 minimum-scale: 最小缩放比例。 maximum-scale: 最大缩放比例。 user-scalable: 是否允许用户缩放。 12345678910&lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/&gt;&lt;!-- 移动端适配的网页: 禁止用户缩放功能，宽度设为设备宽度 --&gt;&lt;meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"/&gt;&lt;!-- iOS 7.1的Safari为meta标签新增 minimal-ui 属性，在网页加载时隐藏地址栏与导航栏 --&gt; 其它预定义的 meta apple-mobile-web-app 的标签组: 123456789&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt;&lt;!-- Web应用程序以全屏模式运行/删除苹果默认的工具栏和菜单栏 --&gt;&lt;meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/&gt;&lt;!-- 设置苹果工具栏颜色 --&gt;&lt;meta name="format-detection" content="telephone=no,email=no,adress=no" /&gt;&lt;!-- 关闭iOS上的内容识别 --&gt; application-name: 如果页面是 Web application，用这个标签表示应用名称。 author: 页面作者。 description: 页面描述，这个属性可能被用于搜索引擎或者其它场合。 generator: 生成页面所使用的工具，主要用于可视化编辑器，如果是手写 HTML 的网页，不需要加这个 meta。 keywords: 页面关键字，对于 SEO 场景非常关键。 referrer: 跳转策略，是一种安全考量。 Open Graph 的标签组: 包括 title, type, URL, site_name, description 和 image，是为 Facebook 分享提供信息 123456789&lt;meta property="og:type" content="website" /&gt;&lt;meta property="og:title" content="mine-website" /&gt;&lt;meta property="og:url" content="https://mine-website.com" /&gt;&lt;meta property="og:description" content="description" /&gt;&lt;meta property="og:image" content="https://mine-website.com/images/image.png"/&gt;&lt;meta property="og:ttl" content="604800" /&gt; renderer: 声明渲染使用的浏览器内核 (360 这一类双核浏览器的约定属性) webkit ie-comp ie 兼容内核 ie-stand ie 标准内核 robots: 机器人协议，声明希望或者不希望搜索引擎或者其他类型的爬虫抓取的部分。 123&lt;meta name="robots" content="index,follow" /&gt;&lt;!-- 或者可以声明拒绝 --&gt;&lt;meta name="robots" content="noindex,nofollow" /&gt; theme-color: 页面风格颜色，实际并不会影响页面，但是浏览器可能据此调整页面之外的 UI（如窗口边框或者 tab 的颜色）。 Twitter 的标签组，包括 card, title, description 和 image，是为 Twitter 分享提供信息 12345678&lt;meta name="twitter:card" content="summary_large_image" /&gt;&lt;meta name="twitter:site" content="@MaterialUI" /&gt;&lt;meta name="twitter:title" content="mine-website" /&gt;&lt;meta name="twitter:description" content="description" /&gt;&lt;meta name="twitter:image" content="https://material-ui.com/static/brand.png"/&gt; 语义相关内容 拓展了纯文本，表达文章结构，不同语言要素的标签 head: 元信息的容器: head 标签规定了自身必须是 html 标签中的第一个标签，它的内容必须包含一个 title，并且最多只能包含一个 base。如果文档作为 iframe，或者有其他方式指定了文档标题时，可以允许不包含 title 标签。 链接 提供到文档内核文档外的链接 替换型元素 引用声音、图片、视频等外部元素替换自身的一类标签 表单 用于填写和提交信息的一类标签 表格 表头、表尾、单元格等表格的结构 总集 语言 实体 命名空间 补充标准]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>重学前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的实现原理与 API]]></title>
    <url>%2Farchives%2Ffront-end%2FBrowser%2F1555985227.html</url>
    <content type="text"><![CDATA[实现原理 从浏览器设计出发,按照解析、构建 DOM 树、计算 CSS、渲染、合成和绘制的流程来理解浏览器的工作原理 浏览器首先使用 HTTP 协议或者 HTTPS 协议,向服务端请求页面； 把请求回来的 HTML 代码经过解析,构建成 DOM 树； 计算 DOM 树上的 CSS 属性； 最后根据 CSS 属性对元素逐个进行渲染,得到内存中的位图； 一个可选的步骤是对位图进行合成,这会极大地增加后续绘制的速度； 合成之后,再绘制到界面上。 解析 HTTP HTTP 协议 从 HTTP 请求回来开始,这个过程并非一般想象中的一步做完再做下一步,而是一条流水线。 从 HTTP 请求回来,就产生了流式的数据,后续的 DOM 树构建、CSS 计算、渲染、合成、绘制,都是尽可能地流式处理前一步的产出: 即不需要等到上一步骤完全结束,就开始处理上一步的输出,这样我们在浏览网页时,才会看到逐步出现的页面。 浏览器首先要做的事就是根据 URL 把数据取回来,取回数据使用的是 HTTP 协议(实际上这个过程之前还有 DNS 查询,不过这里就不详细展开了。) HTTP1.1 rfc2616 HTTP1.1 rfc7234 HTTP 协议是基于 TCP 协议出现的,对 TCP 协议来说,TCP 协议是一条双向的通讯通道,HTTP 在 TCP 的基础上,规定了 Request-Response 的模式。这个模式决定了通讯必定是由浏览器端首先发起的。 大部分情况下,浏览器的实现者只需要用一个 TCP 库,甚至一个现成的 HTTP 库就可以搞定浏览器的网络通讯部分。HTTP 是纯粹的文本协议,它是规定了使用 TCP 协议来传输文本格式的一个应用层协议。 在 TCP 通道中传输的,完全是文本。 在请求部分,第一行被称作 request line,它分为三个部分,HTTP Method,也就是请求的“方法”,请求的路径和请求的协议和版本。 在响应部分,第一行被称作 response line,它也分为三个部分,协议和版本、状态码和状态文本。 紧随在 request line 或者 response line 之后,是请求头 / 响应头,这些头由若干行组成,每行是用冒号分隔的名称和值。 在头之后,以一个空行(两个换行符)为分隔,是请求体 / 响应体,请求体可能包含文件或者表单数据,响应体则是 html 代码。 HTTP 格式 Request request line method GET: 浏览器通过地址栏访问页面都是 GET 方法 POST: 表单提交产生 POST 方法 HEAD: 跟 GET 类似,只返回请求头,多数由 JavaScript 发起 PUT: 添加资源 (非强制约束) DELETE: 删除资源 (非强制约束) CONNECT: 现在多用于 HTTPS 和 WebSocket OPTIONS, TRACE: 一般用于调试,多数线上服务都不支持 path version head body Response response line version status code (状态码) status text (状态文本) head body 状态码和状态文本 1xx: 临时回应,表示客户端请继续。(1xx 的状态被浏览器 http 库直接处理掉了,不会让上层应用知晓) 2xx: 请求成功。 200: 请求成功。 3xx: 表示请求的目标有变化,希望客户端进一步处理。 301: 永久性跳转。 302: 临时性跳转。 304: 跟客户端缓存没有更新。 4xx: 客户端请求错误。 403: 无权限。 404: 表示请求的页面不存在。 418: It’s a teapot. 这是一个彩蛋,来自 ietf 的一个愚人节玩笑。(超文本咖啡壶控制协议) 5xx: 服务端请求错误。 500: 服务端错误。 503: 服务端暂时性错误,可以一会再试。 HTTP Head (HTTP 头) HTTP 头可以看作一个键值对。 原则上,HTTP 头也是一种数据,我们可以自由定义 HTTP 头和值。不过在 HTTP 规范中,规定了一些特殊的 HTTP 头,我们现在就来了解一下它们。 在 HTTP 标准中,有完整的请求 / 响应头规定。 Request Header Request Header 规定 Accept 浏览器端接受的格式 Accept-Encoding 浏览器端接受的编码方式 Accept-Language 浏览器端接受的语言,用于服务端判断多语言 Cache-Control 控制缓存有效性 Connection 连接方式,如果是 keep-alive,且服务端支持,则回复用连接 Host HTTP 访问使用的域名 If-Modified-Since 上次访问时的更改时间,如果服务器端认为此时间后自己没有更新,则会给出 304 响应 If-None-Match 上次访问时使用的 E-Tag,通常是页面的信息摘要,这个比更改时间更准确一些 User-Agent 客户端标识,因为一些历史原因,这是一笔糊涂账,多数浏览器的这个字段都十分复杂,区别十分微妙 Cookie 客户端存储的 cookie 字符串 Response Header Response Header 规定 Cache-Control 缓存控制,用于通知各级缓存保存的时间,例如 max-age=0,标识不要控制缓存 Connection 链接内容,Keep-Alive 表示复用连接 Control-Encoding 内容编码方式,通常是 gzip Control-Length 内容的长度,有利于浏览器判断内容是否已经结束 Control-Type 内容类型,所有请求网页的都是 text/html Date 当前的服务器日期 ETag 页面的信息摘要,用于判断下次请求是否需要重新连接到服务器取回页面 Expires 过期时间,用于判断下次请求是否需要到服务端取回页面 Keep-Alive 保持连接不断时需要的一些信息,如 timeout=5,max=100 Last-Modified 页面上次修改的时间 Server 服务端软件的类型 Set-Cookie 设置 cookie,可以存在多个 Via 服务端的请求链路,对一些调试场景至关重要的一个头 HTTP Request Body HTTP 请求的 body 主要用于提交表单场景。实际上,http 请求的 body 是比较自由的,只要浏览器端发送的 body 服务端认可就可以了。 常见的 body 格式是: application/json application/x-www-form-urlencoded 使用 html 的 form 标签提交产生的 html 请求的默认类型 multipart/form-data 文件上传默认类型 text/xml HTTPS 在 HTTP 协议的基础上,HTTPS 和 HTTP2 规定了更复杂的内容,但是它基本保持了 HTTP 的设计思想,即: 使用上的 Request-Response 模式。 HTTPS 是使用加密通道来传输 HTTP 的内容。但是 HTTPS 首先与服务端建立一条 TLS 加密通道。TLS 构建于 TCP 协议之上,它实际上是对传输的内容做一次加密,所以从传输内容上看,HTTPS 跟 HTTP 没有任何区别。 HTTP 2 HTTP 2 是 HTTP 1.1 的升级版本 HTTP 2.0 最大的改进有两点,一是支持服务端推送,二是支持 TCP 连接复用。 服务端推送能够在客户端发送第一个请求到服务端时,提前把一部分内容推送给客户端,放入缓存当中,这可以避免客户端请求顺序带来的并行度不高,从而导致的性能问题。 连接复用,则使用同一个 TCP 连接来传输多个 HTTP 请求,避免了 TCP 连接建立时的三次握手开销,和初建 TCP 连接时传输窗口小的问题。 Note: 其实很多优化涉及更下层的协议。IP 层的分包情况,和物理层的建连时间是需要被考虑的。 构建 DOM 树 字符流 =&gt; 状态机 =&gt; 词 token =&gt; 栈 =&gt; DOM 树 词(token)的拆解 例如: 1&lt;p class="a"&gt;text text text&lt;/p&gt; &lt;p“标签开始”的开始 class=“a” 属性 &gt; “标签开始”的结束 text text text 文本 &lt;/p&gt; 标签结束 状态机 官方规定了大概八十个状态,HTML 是我见过唯一一个标准中规定了状态机实现的语言,对大部分语言来说,状态机是一种实现而非定义,以下是一个简略逻辑图 状态机的初始状态，我们仅仅区分 “&lt; ”和 “非 &lt;”： 如果获得的是一个非 &lt; 字符，那么可以认为进入了一个文本节点； 如果获得的是一个 &lt; 字符，那么进入一个标签状态。 不过当我们在标签状态时，则会面临着一些可能性。 比如下一个字符是“ ! ” ，那么很可能是进入了注释节点或者 CDATA 节点。 如果下一个字符是 “/ ”，那么可以确定进入了一个结束标签。 如果下一个字符是字母，那么可以确定进入了一个开始标签。 如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。 用状态机做词法分析，其实正是把每个词的“特征字符”逐个拆开成独立状态，然后再把所有词的特征字符链合并起来，形成一个联通图结构。 DOM 树 栈顶元素就是当前节点 遇到属性，就添加到当前节点 遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点 遇到注释节点，作为当前节点的子节点 遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点 遇到 tag end 就出栈一个节点（还可以检查是否匹配） 计算 CSS 渲染、合成和绘制 渲染 把模型变成位图的过程 这里的位图就是在内存里建立一张二维表格，把一张图片的每个像素对应的颜色保存进去（位图信息也是 DOM 树中占据浏览器内存最多的信息，我们在做内存占用优化时，主要就是考虑这一部分）。 浏览器中渲染这个过程，就是把每一个元素对应的盒变成位图。这里的元素包括 HTML 元素和伪元素，一个元素可能对应多个盒（比如 inline 元素，可能会分成多行）。每一个盒对应着一张位图。 这个渲染过程是非常复杂的，但是总体来说，可以分成两个大类：图形和文字。 盒的背景、边框、SVG 元素、阴影等特性，都是需要绘制的图形类。这就像我们实现 HTTP 协议必须要基于 TCP 库一样，这一部分，我们需要一个底层库来支持。 一般的操作系统会提供一个底层库，比如在 Android 中，有大名鼎鼎的 Skia，而 Windows 平台则有 GDI，一般的浏览器会做一个兼容层来处理掉平台差异。 合成 合成是英文术语 compositing 的翻译，这个过程实际上是一个性能考量，它并非实现浏览器的必要一环。 主流浏览器一般根据 position、transform 等属性来决定合成策略，来“猜测”这些元素未来可能发生变化。 但是，这样的猜测准确性有限，所以新的 CSS 标准中，规定了 will-change 属性，可以由业务代码来提示浏览器的合成策略，灵活运用这样的特性，可以大大提升合成策略的效果。 绘制 绘制是把“位图最终绘制到屏幕上，变成肉眼可见的图像”的过程，不过，一般来说，浏览器并不需要用代码来处理这个过程，浏览器只需要把最终要显示的位图交给操作系统即可。 API API 的主要介绍: 事件、DOM、CSSOM 几个部分,它们分别覆盖了交互、语义和可见效果 DOM CSSOM 事件 API 总集合]]></content>
      <categories>
        <category>前端</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>重学前端</tag>
        <tag>性能</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 内存管理]]></title>
    <url>%2Farchives%2Ffront-end%2FJavaScript%2F1553130751.html</url>
    <content type="text"><![CDATA[什么是内存泄漏？ 当我们决定不再使用某些内存时，由于错误的编码，未能使得 GC(Gabbage Collection)正确的将这些内存回收的情况，就是内存泄漏。 内存的占用 一个对象占用的内存分为直接占用内存(Shallow Size)和占用总内存(Retained Size)，赋值和 New 操作都会涉及到内存的占用。 直接占用内存：对象本身占用的内存。典型的 JavaScript 对象都会有保留内存用来描述这个对象和存储它的直接值。一般，只有数组和字符串会有明显的直接占用内存(Shallow Size)。但字符串和数组常常会在渲染器内存中存储主要数据部分，仅仅在 JavaScript 对象栈中暴露一个很小的包装对象。 占用总内存：直接占用内存和这个引用的依赖对象所占用的内存。 内存的分配 Chrome V8 的垃圾回收（GC）算法基于 Generational Collection，内存被划分为两种，分别称为 Young Generation（YG）和 Old Generation（OG）。 所谓 Young 和 Old 是根据他们占用的时间来划分的。内存在 YG 的分配和回收快而频繁，一般存在的时间很短，所以称为 Young；而在 OG 中则慢而少发生，所以称为 Old。 因为在 V8 中，YG 的 GC 过程会阻塞程序，而 OG 的 GC 不会阻塞。所以通常情况下开发者更关心 YG 的细节。 YG 又被平分为两部分空间，分别称为 From 和 To。所有内存从 To 空间被分配出去，当 To 满时，开始触发 GC，接下来细看一下。 某时刻，To 已经分 A、B 和 C 分配了内存，当前它剩下一小块内存未分配出去，而 From 所有的内存都空闲着。 此时，一个程序需要为 D 分配内存，但 D 需要的内存大小超出了 To 未分配的内存，如下图。此时，触发 GC，页面停止执行。 接着 From 和 To 进行对换，即原来的 To 空间被标志为 From，From 被标志为 To。并且把活的变量值（例如 B）标志出来，而”垃圾“（例如 AC）未被标志，它们将会被清掉。 活的 B 会被复制到 To 空间，而「垃圾」AC 则被回收，同时，D 被分配到 To 空间，最后成下图的分布 至此，整个 GC 完成，此过程中页面停止执行，所以要尽可能的快。当 YG 中的值存活比较久时，它会被推向 OG，OG 的空间满时，触发 OG 内的 GC，OG 的 GC 时会触发 YG 的 GC。 每次分配都使 To 的可用空间减小，程序又更接近 GC YG 的 GC 会阻塞程序，所以 GC 时间不宜太长 10ms 以内，因为 16ms 就会出现丢帧；GC 不宜太频繁 某个值变成垃圾后，不会立马释放内存，只有在 GC 的时候所占内存才会被回收。 内存的回收 GC Root 是内存的根结节，在浏览器中它是 window，在 NodeJS 中则是 global 对象。 从 GC Root 开始遍历图，所有能到达的节点称为活节点，如果存在 GC Root 不能到达的节点，那么该节点称为“垃圾”，将会被回收，如图中灰色的节点。 至于根节点的回收，不受用户的控制。 导致内存泄漏的原因 没有完全切断与 GC root 之间的路径 因为没有完全切断与根节点之间的路径，导致自动 GC 不会回收这部分内存，从而造成内存泄漏。 对象之间的相互引用 123var a, b;a.reference = b;b.reference = a; 错误使用了全局变量 123a = '1234567';相当于;window.a = '1234567'; DOM 元素清空或删除时，绑定的事件未清除 1234567891011&lt;div id="myDiv"&gt; &lt;input type="button" value="Click me" id="myBtn" /&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var btn = document.getElementById('myBtn'); btn.onclick = function() &#123; document.getElementById('myDiv').innerHTML = 'Processing...'; /* 清除事件绑定 */ // btn.onclick = null; &#125;;&lt;/script&gt; 闭包引用 12345678910function bindEvent() &#123; var obj = document.getElementById('xxx'); obj.onclick = function() &#123; /** 空函数*/ &#125;; /** delete this reference */ // obj = null;&#125; DOM 元素清空或删除时，子元素存在 JS 引用，导致子元素的所有父元素都不会被删除 123456// b是a的子dom节点, a是body的子节点var aElement = document.getElementById('a');var bElement = document.getElementById('b');document.body.removeChild(aElement);// aElement = null；// bElement = null; 过度占用了内存空间 更多的出现在 nodejs 中，例如： 无节制的循环 123while (1) &#123; // do sth&#125; 过大的数组 1234567var arr = [];for (var i = 0; i &lt; 100000000000; i++) &#123; var a = &#123; desc: 'an object', &#125;; arr.push(a);&#125; 参考文献 《Chrome 开发者工具之 JavaScript 内存分析》 原文链接]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web开发</tag>
        <tag>浏览器</tag>
        <tag>转载</tag>
        <tag>Storage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式速查表]]></title>
    <url>%2Farchives%2FRegExp%2F1552532351.html</url>
    <content type="text"><![CDATA[JavaScript 正则快速查询 正则表达式速查表 字符 描述 例子 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。 “n”匹配字符“n”。“\n”匹配一个换行符。串行“\\”匹配“\”而“\(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^也匹配“\n”或“\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了 RegExp 对象的 Multiline 属性，$也匹配“\n”或“\r”之前的位置。 * 匹配前面的子表达式零次或多次。 zo*能匹配“z”以及“zoo”。*等价于{0,}。 + 匹配前面的子表达式一次或多次。 “zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。 “do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。 “o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个 o。 {n,} n是一个非负整数。至少匹配n次。 “o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有 o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。 “o{1,3}”将匹配“fooooood”中的前三个 o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,*m*}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。 对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.|\n)”的模式。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在 VBScript 中使用 SubMatches 集合，在 JScript 中则使用$0…$9 属性。要匹配圆括号字符，请使用“\(”或“\)”。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。 “industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。 (?=pattern) 正向肯定预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。 “Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。 “Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。 “(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 (?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。 “(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。 x|y 匹配 x 或 y。 “z|food”能匹配“z”或“food”。“(z|f)ood”则匹配“zood”或“food”。 [xyz] 字符集合。匹配所包含的任意一个字符。 “[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。 “[^abc]”可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。 “[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。 “[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。 “er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \B 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \cx 匹配由 x 指明的控制字符。 \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的“c”字符。 \d 匹配一个数字字符。等价于[0-9]。 \D 匹配一个非数字字符。等价于[^0-9]。 \f 匹配一个换页符。等价于\x0c 和\cL。 \n 匹配一个换行符。等价于\x0a 和\cJ。 \r 匹配一个回车符。等价于\x0d 和\cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于[^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于\x09 和\cI。 \v 匹配一个垂直制表符。等价于\x0b 和\cK。 \w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。 “\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用 ASCII 编码。 *num* 匹配num，其中num是一个正整数。对所获取的匹配的引用。 “(.)\1”匹配两个连续的相同字符。 *n* 标识一个八进制转义值或一个向后引用。如果*n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n*为一个八进制转义值。 *nm* 标识一个八进制转义值或一个向后引用。如果*nm之前至少有nm个获得子表达式，则nm为向后引用。如果*nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则*nm将匹配八进制转义值nm*。 *nml* 如果n为八进制数字（0-3），且m 和 l均为八进制数字（0-7），则匹配八进制转义值nml。 \un 匹配n，其中n是一个用四个十六进制数字表示的 Unicode 字符。 \u00A9 匹配版权符号（©）。 常用正则表达式 用户名 /^[a-z0-9_-]{3,16}$/ 密码 /^[a-z0-9_-]{6,18}$/ 十六进制值 /^#?([a-f0-9]{6}|[a-f0-9]{3})$/ 电子邮箱 /^([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})$/ /^[a-z\d]+(.[a-z\d]+)*@(\da-z?)+(.{1,2}[a-z]+)+$/ URL /^(https?://)?([\da-z.-]+).([a-z.]{2,6})([/\w .-])/?$/ IP 地址 /((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)/ /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/ HTML 标签 /^&lt;([a-z]+)([^&lt;]+)(?:&gt;(.)&lt;/\1&gt;|\s+/&gt;)$/ 删除代码\注释 (?&lt;!http:|\S)//.*$ Unicode 编码中的汉字范围 /^[\u2E80-\u9FFF]+$/ 淘宝淘口令 /￥([\w\s]+)￥/ URL /(?:http QQ 垃圾信息 /(?:[加qQ企鹅号码\s]{2,} 微信垃圾信息 /(?:[加+微＋+➕薇？vV威卫星♥❤姓xX信]{2,}]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>归纳</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker知识点整理]]></title>
    <url>%2Farchives%2Fdocker%2FContinuous-Integration%2F1549248860.html</url>
    <content type="text"><![CDATA[前段时间在做 Wechaty 相关的项目，使用 Docker 的体验远远要超出我之前的想象。不管是开发过程中还是开发之后交付的流程都会简化很多。 以下是我目前一些整理，之后可能会有更深度的学习吧！ Docker 是什么 Docker 是基于 Go 语言实现的云开源项目，诞生于 2013 年初，最初是由 dotCloud 公司发起。 通过对应用组件的封装、分发、部署、运行等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里应用组件，即可以是 Web 应用，也可以是一套数据库服务，甚至是一个操作系统或编译器。 Docker 由镜像(Image)、容器(Container)、仓库(Repository) 三大核心组成。 优势 更快速的交付和部署: 开发人员可以通过镜像来快速构建一套标准的开发环境; 开发完成之后，测试和运维人员也可以直接使用相同环境来部署代码。 更轻松的迁移和扩展: Docker 容器几乎可以在任意平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等，在不同的平台可以很轻松地迁移应用。 更简单的更新管理: 使用 Dockerfile，只需要修改小小的配置，就可以替代以往大量的更新工作。 场景示例-传统开发流程 场景示例-Docker 环境开发流程 与传统虚拟机对比 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为 MB 一般为 GB 性能 接近原生 弱于原生 系统支持量 单机支持上千个容器 一般几十个 常用指令 123456# 查看docker版本docker version# 显示docker系统的信息docker info# 日志信息docker logs 1docker run [OPTIONS] IMAGE [COMMAND] [ARG...] - **-a stdin:** 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； - **-d:** 后台运行容器，并返回容器ID； - **-i:** 以交互模式运行容器，通常与 -t 同时使用； - **-p:** 端口映射，格式为：**主机(宿主)端口:容器端口** - **-t:** 为容器重新分配一个伪输入终端，通常与 -i 同时使用； - **--name=&quot;nginx-lb&quot;:** 为容器指定一个名称； - **--dns 8.8.8.8:** 指定容器使用的DNS服务器，默认和宿主一致； - **--dns-search example.com:** 指定容器DNS搜索域名，默认和宿主一致； - **-h &quot;mars&quot;:** 指定容器的hostname； - **-e username=&quot;ritchie&quot;:** 设置环境变量； - **--env-file=[]:** 从指定文件读入环境变量； - **--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;:** 绑定容器到指定CPU运行； - **-m :**设置容器使用内存最大值； - **--net=&quot;bridge&quot;:** 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； - **--link=[]:** 添加链接到另一个容器； - **--expose=[]:** 开放一个端口或一组端口； 12345678# 查看最新创建的容器docker ps -l# 启动一个或多个已经被停止的容器docker start [OPTIONS] CONTAINER [CONTAINER...]# 停止一个或多个运行中的容器docker stop [OPTIONS] CONTAINER [CONTAINER...]# 重启容器docker restart [OPTIONS] CONTAINER [CONTAINER...]]]></content>
      <categories>
        <category>docker</category>
        <category>持续集成</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>归纳</tag>
        <tag>Nodejs</tag>
        <tag>service</tag>
        <tag>docker</tag>
        <tag>持续集成</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于'Bug-O'表示法]]></title>
    <url>%2Farchives%2Ffront-end%2Fnetwork-request%2F1549245751.html</url>
    <content type="text"><![CDATA[当你在编写对性能敏感的代码时，最好记住他的算法复杂性。它通常表达用 Big-O 表示法表示。 Big-O 衡量代码在向其投入更多数据时会变慢多少。例如，如果一个排序算法具有 O(n2) 的复杂度，则排序 ×50 倍以上的项目大致将变慢 502 = 2,500 倍。Big O 不会给你一个确切的数字，但它可以帮助你理解算法如何拓展。 一些例子：O(n), O(n log n), O(n2), O(n!)。 但是, 这篇文章与算法或性能无关，它主要描述关于 API 和调试的。事实证明，API 设计涉及一些考虑因素非常类似。 我们大部分时间都用于查找和修复代码中的错误。大多数开发人员希望能够更快的发现错误。尽管最终可能是个令人满意的结果，但是如果你已经实施了开发路线中的某些内容，那么花费整天的时间来追逐单个的错误会很糟糕。 调式经验会影响我们对抽象、库和工具的选择。一些 API 和语言设计使得错误变得不可能。有些则会导致错误无穷无尽，但是该如何分辨呢？ 关于 API 的许多在线讨论主要关注美学，却没有谈到很多在实际项目中使用 API 的感觉。 我有一个指标可以帮助我思考这个问题。我管它叫 Bug-O 表示法： 🐞(n) Big-O描述了随着输入的增长，算法慢了多少，也描述了随着代码库的增长，API 速度慢了多少。 例如，思考以下代码，它会随着时间的推移使用node.appendChild()，node.removeChild()手动更新 DOM，且不会指明具体的结构： 1234567891011121314151617181920212223242526function trySubmit() &#123; // Section 1 let spinner = createSpinner(); formStatus.appendChild(spinner); submitForm() .then(() =&gt; &#123; // Section 2 formStatus.removeChild(spinner); let successMessage = createSuccessMessage(); formStatus.appendChild(successMessage); &#125;) .catch((error) =&gt; &#123; // Section 3 formStatus.removeChild(spinner); let errorMessage = createErrorMessage(error); let retryButton = createRetryButton(); formStatus.appendChild(errorMessage); formStatus.appendChild(retryButton); retryButton.addEventListener('click', function() &#123; // Section 4 formStatus.removeChild(errorMessage); formStatus.removeChild(retryButton); trySubmit(); &#125;); &#125;);&#125; 这段代码的问题并非它“很丑”，我们也不是在讨论着是否符合美学。问题是，如果代码中存在问题，我该从何开始排查。 根据回调和事件触发的顺序，程序中可能采用的代码路径组合数量可能会爆炸。某些情况下，可能会展示正确匹配的信息。但也可能看到多个提示，故障和错误信息同时存在，更有可能崩溃。 此功能有 4 个不同的部分，且顺序也不固定。粗略估算他们可能有 4×3×2×1 = 24 种不同顺序的运行方式。如果我在添加四个代码段，他将是 8×7×6×5×4×3×2×1——四万种组合。如果尝试调试，那么祝你好运。 换句话说，Bug-O 这种表示法就是 🐞(n!)，其中n是触及 DOM 的代码段的数量。是的，这会是一个因素，尽管我在这里使用的方法不太科学。在实践中并非所有转换都是可能的，但这些戏份中的每一个都可能运行多次。🐞(¯(ツ)/¯)这样做可能会更准确，但它任很糟糕。我们应该做的更好。 为了改进代码中的 Bug-O，我们可以限制可能的状态和结果的数量。我们不需要任何库来执行此操作，这只是在我们的代码上强制执行某些结构可以解决的。以下就是其中的一种方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243let currentState = &#123; step: 'initial', // 'initial' | 'pending' | 'success' | 'error'&#125;;function trySubmit() &#123; if (currentState.step === 'pending') &#123; // Don't allow to submit twice return; &#125; setState(&#123; step: 'pending' &#125;); submitForm .then(() =&gt; &#123; setState(&#123; step: 'success' &#125;); &#125;) .catch((error) =&gt; &#123; setState(&#123; step: 'error', error &#125;); &#125;);&#125;function setState(nextState) &#123; // Clear all existing children formStatus.innerHTML = ''; currentState = nextState; switch (nextState.step) &#123; case 'initial': break; case 'pending': formStatus.appendChild(spinner); break; case 'success': let successMessage = createSuccessMessage(); formStatus.appendChild(successMessage); break; case 'error': let errorMessage = createErrorMessage(nextState.error); let retryButton = createRetryButton(); formStatus.appendChild(errorMessage); formStatus.appendChild(retryButton); retryButton.addEventListener('click', trySubmit); break; &#125;&#125; 这样代码可能会看起来不太一样，甚至显得有些冗长。但这个思路下，调试会非常简单： 1234function setState(nextState) &#123; // Clear all existing children formStatus.innerHTML = ''; // ... the code adding stuff to formStatus ... 通过在执行任何操作之前清除表单状态来保证我们的 DOM 操作始终从头开始。这就是我们如何对抗不可避免的熵（entropy） — 拒绝让错误堆积。这就相当于“关闭再打开”编码，它的效果非常的好。 如果在输出中出现错误，我们只需要考虑一个退一步——上一次 setState 的调用。调试渲染结果的 Bug-O 是 🐞(n)，其中n是渲染代码路径的数量。这里只有四个（因为我们在switch中只有四个case）。 我们在设置状态时，任然存在竞争条件，但调试它们会更容易，因为我们可以记录检查每个中间状态。我们还可以明确禁止任何不需要的转换： 12345function trySubmit() &#123; if (currentState.step === 'pending') &#123; // Don't allow to submit twice return; &#125; 当然，总是要权衡重置 DOM 是必要的。每次都要过分删除或重建 DOM 会破坏其内部状态，失去焦点，并在较大的应用程序中导致可怕的性能问题。 这也是为什么像是 React 这样的库会很有帮助。因为它们总是让你在开始重建 UI 的范例中思考，而不必这么做： 1234567891011121314151617181920212223242526272829303132333435363738394041function FormStatus() &#123; let [state, setState] = useState(&#123; step: 'initial', &#125;); function handleSubmit(e) &#123; e.preventDefault(); if (state.step === 'pending') &#123; // Don't allow to submit twice return; &#125; setState(&#123; step: 'pending' &#125;); submitForm .then(() =&gt; &#123; setState(&#123; step: 'success' &#125;); &#125;) .catch((error) =&gt; &#123; setState(&#123; step: 'error', error &#125;); &#125;); &#125; let content; switch (state.step) &#123; case 'pending': content = &lt;Spinner /&gt;; break; case 'success': content = &lt;SuccessMessage /&gt;; break; case 'error': content = ( &lt;&gt; &lt;ErrorMessage error=&#123;state.error&#125; /&gt; &lt;RetryButton onClick=&#123;handleSubmit&#125; /&gt; &lt;/&gt; ); break; &#125; return &lt;form onSubmit=&#123;handleSubmit&#125;&gt;&#123;content&#125;&lt;/form&gt;;&#125; 代码可能会有区别，但原理是相同的。组件抽象强制执行边界，会让你知道页面上是否有其他代码可以混淆其 DOM 或状态。 组件化有利于减少 Bug-O。 事实上，如果任何值在 React app 中看起来不对，你都可以通过在 React 树中逐一查看其上方组件的代码来追踪来源。无论应用程序大小，追踪到的渲染值是 🐞(树的层级)。 **下次你看到关于 API 的讨论时，想想在常见的调试任务中 🐞(n)是怎样的？**现在的那些 API 和原则中，你熟悉的那些如何呢？Redux，CSS，inheritance——它们都有自己的 Bug-O。 原文链接： The “Bug-O” Notation]]></content>
      <categories>
        <category>前端</category>
        <category>网络请求</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>算法</tag>
        <tag>接口</tag>
        <tag>API</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么选择Hook而非……?]]></title>
    <url>%2Farchives%2Ffront-end%2Fframe%2FReact%2FHooks%2F1549245486.html</url>
    <content type="text"><![CDATA[自从第一个关于React Hooks的 alpha 版本发布以来，有一个问题不断出现在讨论中：“为什么是 Hook 而非 &lt;一些其他的 API&gt; ？” 提示一下，以下的这些就是Hooks： useState() 用于声明一个状态变量。 useEffect() 用于声明一个补充规则(side effect)。 useContext() 用于读取一些上下文的内容。 但是仍有一些其他的 API，例如React.memo()和&lt;Context.Provider&gt;，它们不是Hooks。通常提出的 Hook 版本会建议是noncompositional或者antimodular。本文将帮助你了解原因。 提示：这篇文章对那些对 API 讨论感兴趣的人来说是一个深刻的话题，你不需要考虑使用 React 来提升效率！ 前提 我们希望 React API 保留两个重要属性： 构成 Composition: 定制 Hooks很大程度上是我们对 Hooks API 感到兴奋的原因。我们希望大家可以频繁的构建自己的 Hooks，并且我们需要保证不同人写的 Hooks不会发生冲突。（我们大概会被编写清爽且不会相互破坏的组件这样的体验宠坏吧！） 调试 Debugging: 我们希望随着程序的增长，Bugs很容易找到。React 的最佳特征之一就是——如果你看到呈现出了任何错误，都能够通过结构树找到那个组件的 prop 或 state 导致的错误。 这两个约束放在一起可以告诉我们什么可以或不可以使用 Hook。让我们看几个例子。 使用 Hook：useState() 构成 Composition 每个调用useState()的多个自定义 Hook 都不会冲突： 123456789101112131415function useMyCustomHook1() &#123; const [value, setValue] = useState(0); // What happens here, stays here.&#125;function useMyCustomHook2() &#123; const [value, setValue] = useState(0); // What happens here, stays here.&#125;function MyComponent() &#123; useMyCustomHook1(); useMyCustomHook2(); // ...&#125; 添加一个新的无条件useState()调用总是安全的。你不需要了解组件用于声明新状态变量的其他 Hook，也不能通过更新其中一个来破坏其他的状态变量。 结论： ✅ useState()不会使自定义 Hook 易碎。 调试 Debugging 钩子会很有用，因为你可以用过它传递值： 12345678910111213141516function useWindowWidth() &#123; const [width, setWidth] = useState(window.innerWidth); // ... return width;&#125;function useTheme(isMobile) &#123; // ...&#125;function Comment() &#123; const width = useWindowWidth(); const isMobile = width &lt; MOBILE_VIEWPORT; const theme = useTheme(isMobile); return &lt;section className=&#123;theme.comment&#125;&gt;&#123;/* ... */&#125;&lt;/section&gt;;&#125; 但是如果我们犯错了呢？该如何调试？ 假设我们从theme.comment获得的 CSS 类是错误的，我们该如何调试？我们可以在组件的主体中设置断点或几个日志输出。 也许我们会看到theme错误但是width和isMobile是正确的。这会告诉我们问题是useTheme()中的。或者也许我们会看到width本身就是错的，那我们就应该查看useWindowWidth()。 单独查看中间值会告诉我们顶层的那些 Hook 包含 Bug。我们不需要查看他们所有的实现。 然后我们可以“放大”有 Bug 的部分并尝试复现。 随着自定义 Hook 嵌套的深度增加，这会变得更加重要。想象我们有 3 个级别的自定义 Hook 嵌套，每个级别使用 3 个不同的自定义 Hooks。寻找3 处与潜在检查3 + 3×3 + 3×3×3 = 39 处之间的差异是巨大的。幸运的是，useState()不能神奇的“影响”其他钩子或组件，它返回的错误值会在它后面留下一条痕迹，就像任何变量一样。🐛 结论： ✅ useState()不会遮掩我们代码中的因果关系，我们可以直接通过痕迹追踪到 Bug。 不应使用 Hook：useBailout() 作为优化，使用 Hooks 的组件可以避免重新渲染。 一种方法是将整个组件周围方式一个React.memo()包装器。如果 props 与我们在上一次渲染的过程中的 props 非常相等，他就会失去重新渲染的效果，这很类似PureComponent类。 React.memo()接受一个组件并返回一个组件： 1234function Button(props) &#123; // ...&#125;export default React.memo(Button); 但是为什么它不仅是个 Hook? 无论你将它成为useShouldComponentUpdate()，usePure()，useSkipRender()或useBailout()，这个体验往往看起来是这样的： 123456function Button(&#123; color &#125;) &#123; // ⚠️ Not a real API useBailout((prevColor) =&gt; prevColor !== color, color); return &lt;button className=&#123;'button-' + color&#125;&gt;OK&lt;/button&gt;;&#125; 还有一些变化（eg：一个简单的usePure()标记）但是在广泛的笔划中他们具有相同的缺陷。 构成 Composition 假设我们尝试将useBailout()放在两个自定义 Hooks 中： 12345678910111213141516171819202122232425function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); // ⚠️ Not a real API useBailout(prevIsOnline =&gt; prevIsOnline !== isOnline, isOnline); useEffect(() =&gt; &#123; const handleStatusChange = (status) =&gt; setIsOnline(status.isOnline); ChatAPI.subscribe(friendID, handleStatusChange); return () =&gt; ChatAPI.unsubscribe(friendID, handleStatusChange); &#125;); return isOnline;&#125;function useWindowWidth() &#123; const [width, setWidth] = useState(window.innerWidth); // ⚠️ Not a real API useBailout(prevWidth =&gt; prevWidth !== width, width); useEffect(() =&gt; &#123; const handleResize = () =&gt; setWidth(window.innerWidth); window.addEventListener('resize', handleResize); return () =&gt; window.removeEventListener('resize', handleResize); &#125;); return width;&#125; 现在如果你在同一个组件使用它们会发生什么？ 12345678910function ChatThread(&#123; friendID, isTyping &#125;) &#123; const width = useWindowWidth(); const isOnline = useFriendStatus(friendID); return ( &lt;ChatLayout width=&#123;width&#125;&gt; &lt;FriendStatus isOnline=&#123;isOnline&#125; /&gt; &#123;isTyping &amp;&amp; 'Typing...'&#125; &lt;/ChatLayout&gt; );&#125; 什么时候重新渲染？ 如果每个useBailout()调用都有权跳过更新，那么来自useWindowWidth()的更新将被useFriendStatus()阻塞，反之亦然。这些 Hook 会相互破坏。 但是，如果useBailout()尽在单个组件内的所有调用“同意”阻止更新时才能使用，那么我们的ChatThread将无法更新isTypingprop 的更改。 更糟糕的是，使用这些语义任何新添加到 ChatThread 的 Hook 如果没有调用 useBailout()将会损坏。否则，他们不能“反对”使用useWindowWidth()和 useFriendStatus()救助。 结论： 🔴 useBailout()打破了构建方式，将其添加到 Hook 会破坏其他 Hook 的状态更新。我们希望 API 可以具有防碎性，而这种行为却背道而驰。 调试 Debugging 像useBailout()这样的 Hook 如何影响调试？ 我们将使用相同的示例： 12345678910function ChatThread(&#123; friendID, isTyping &#125;) &#123; const width = useWindowWidth(); const isOnline = useFriendStatus(friendID); return ( &lt;ChatLayout width=&#123;width&#125;&gt; &lt;FriendStatus isOnline=&#123;isOnline&#125; /&gt; &#123;isTyping &amp;&amp; 'Typing...'&#125; &lt;/ChatLayout&gt; );&#125; 当我们期望Typing...标签不会出现，即便在上层的 prop 正在发生变化。我们该怎么调试？ 通常，在 React 中你自信可以通过查找来给出确切的回答。如果ChatThread没能得到一个新的isTyping值，我们可以打开呈现&lt;ChatThread isTyping={myVar} /&gt;的组件并检查myVar，以此类推。在其中一个级别，我们要么找到一个错误的shouldComponentUpdate()救助，要么传递不正确的isTyping值。一看链中的每个组件通常足以追寻到问题的根源。 但是如果这个useBailout()Hook 是真的，你永远也不会知道更新被跳过的原因，知道你检查我们的ChatThread及其所有者链中的组件使用的每个自定义 Hook（的深度）。由于每个父组件也可以使用自定义 Hook，因此拓展非常糟糕。 就像你在抽屉里寻找一把螺丝刀一样，每个抽绎都有一堆较小的抽屉柜，你不知道兔子洞有多深。 结论： 🔴 useBailout()Hook 不仅打破了构建，更大大增加了调试步骤和求助所需的认知门槛——在某些情况下，呈指数式增加。 我们只看到了一个真正的 Hook，useState()，还有一个关于不该使用Hook 的常规建议——useBailout()。我们通过构建和调试的棱镜对他们进行了比较，讨论了它们中工作与否的原因。 虽然没有memo()和shouldComponentUpdate()的“Hook 版本”，但 React会提供一个 Hook 调用useMemo()的方法。它有类似的用途，但它语义不同，并不会遭遇上述陷阱。 useBailout()只是一个不该使用 Hook 工作的例子，还有很多类似的——例如：useProvider()，useCatch()或useSuspense()。 你明白为什么吗？ （小声：组成…调试…） Discuss on Twitter • Edit on GitHub 原文链接： Why Isn’t X a Hook?]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
        <category>React</category>
        <category>Hooks</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMAScript</tag>
        <tag>Web开发</tag>
        <tag>框架</tag>
        <tag>性能</tag>
        <tag>译文</tag>
        <tag>React</tag>
        <tag>Programming</tag>
        <tag>React Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将React作为UI运行]]></title>
    <url>%2Farchives%2Ffront-end%2Fframe%2FReact%2F1549201490.html</url>
    <content type="text"><![CDATA[大多数教程都将 React 作为 UI 库来引入。这逻辑上是对的，因为 React 就是一个 UI 库，标语中就是这么表述的！ 我之前写过关于创建用户界面的挑战。但这篇文章却是以不同的方式讨论 React——更像是运行时系统（programming runtime）. 这篇文章不会教你如何创建用户界面。但是它可能会帮助你更深入地理解 React 编程模式。 提示：如果你正在学习 React，请查看文档。 ⚠️ 这是个深度讨论帖 — 内容对初学者很不友好。在这篇文章中，我从第一原则描述了大部分 React 编程模型，但并不会解释如何使用它——他是如何工作的。 它面向有经验的程序猿和从事其他 UI 库的人，他们询问了在 React 中选择的一些权衡。我希望你们会觉得它很有用！ 很多人成功使用 React 多年但没有考虑大多数这些话题。与其说这是以设计师为中心，这显然更会是以程序猿为中心的 React 视角。尽管我认为同时提供双方的资源并不会造成很大的负荷。 在免责声明之后，让我们开始进入正题吧！ 主树 Host Tree 有些程序输出数字，有些输出诗歌。不同的语言及其运行时通常针对特定的一组用例进行优化，而 React 也不例外。 React 程序通常输出一个可能随时间变化的树。它可能是个DOM 树，一个iOS 层次结构，一个PDF 原语树，甚至是JSON 对象。但是通常我们希望用它表示一些 UI。我们称它为“host tree”，因为它是 React Host 环境外显的一部分——就像是 DOM 或 iOS 一样。通常 Host Tree它有 自己的命令式 API。React 是在它上面的一层。 那么 React 有什么用呢？非常抽象的说，它帮助你编写一个程序，这个程序可以预测操作复杂的 Host Tree 以响应外部事件，如交互、网络响应、计时器等。 当专用工具可以施加特定的约束并从中受益时，它比通用工具做得更好。React 依托于两个原则： **稳定性：**Host Tree 相对稳定且大多更新都不会彻底改变其整体结构，如果一个应用程序每秒钟都将其所有交互元素重新组合成完全不同的组合，就很难使用。那个按钮去哪儿了？为什么屏幕在变化？ **规则性：**Host Tree 可以分解为外观和行为一致的 UI 模式（如按钮、列表、虚拟人物），而不是随机形状。 这些原则恰好适用于大多数 UI。但是，如果输出中没有稳定的“模式”，那么 React 就不合适了。例如：React 可以帮助你编写一个 Twitter 的客户端，但是对于3D 管道屏保程序就不是那么便利了。 主实例 Host Instances Host Tree 由节点组成，我们将它们称为“Host 实例”。 在 DOM 环境中，Host 实例是常规的 DOM 节点——就像调用document.createElement('div')时得到的对象一样。在 iOS 上，Host 实例可以是从 javascript 唯一标识本机视图的值。 Host 实例有自己的属性（eg：domNode.className或view.tintColor）。它们还可以包含其他作为子元素的 Host 实例。 （这与 React 无关——我描述的是 Host 实例） 通常有一个 API 来操作 Host 实例。例如，DOM 提供了诸如appendChild、removeChild、setAttribute等 API。在 React 应用程序中，通常不调用这些 API。这是 React 的工作。 渲染器 Renderers 一个渲染器教导 React 与特定的 Host 环境对话并管理其 Host 实例。React DOM、React Native 甚至Ink都是 React 渲染器。也可以创建自己的 React 渲染器。 React 渲染器可以在两种模式之一下工作。 绝对多数渲染器都是使用“突变”模式编写的。这个模式就是 DOM 的工作方式：我们可以创建一个节点，设置它的属性，然后从中添加或删除子节点。Host 实例是完全可变的。 React 也可以在“持久”模式下工作。此模式适用于不提供appendChild()等方法，而是克隆父树并始终替换顶级子级的主机环境。Host Tree 级别的不可变性使多线程更容易实现。React Fabric利用了这一点。 作为一个 React 用户并不需要考虑这些模式，我只想强调 React 不仅仅是从一种模式到另一种模式的适配器，其效能与目标低级视图 API 范式是正交的。 React Elements 在 Host 环境中，一个 Host 实例（如 DOM 节点）是最小的构建块。在 React 中，最小的构建块是一个React element. React element 是一个普通的 JavaScript 对象，它可以描述Host 实例。 123456// JSX is a syntax sugar for these objects.// &lt;button className="blue" /&gt;&#123; type: 'button', props: &#123; className: 'blue' &#125;&#125; 一个 React element 是轻量级的，没有绑定到他的 Host 实例，同样它也只是你期望在屏幕上可见内容的描述。 与 Host 实例一样，React elements 也可以形成树： 1234567891011121314151617// JSX是这些对象的语法糖。// &lt;dialog&gt;// &lt;button className="blue" /&gt;// &lt;button className="red" /&gt;// &lt;/dialog&gt;&#123; type: 'dialog', props: &#123; children: [&#123; type: 'button', props: &#123; className: 'blue' &#125; &#125;, &#123; type: 'button', props: &#123; className: 'red' &#125; &#125;] &#125;&#125; （提示：我省略了一些对这个解释不重要的属性。） 但是请记住：React elements 没有自己的持久标识。它们理当被重建直到丢弃。 React elements 是不变的。例如不能改变子元素、属性或 React element。如果以后要呈现不同的内容，则应当从头使用新建的 React element 结构来描述。 我喜欢吧 React elements 理解成电影中的画面，它们捕获用户界面在特定时间的外观，但它们不会变。 入口 Entry Point 每个 React 渲染器都有一个“入口”。正是 API 让我们告诉 React 在容器的 Host 实例中呈现特定的 React 元素树 例如，React DOM 入口是ReactDOM.render： 12345ReactDOM.render( // &#123; type: 'button', props: &#123; className: 'blue' &#125; &#125; &lt;button className="blue" /&gt;, document.getElementById('container'),); 当我们说ReactDOM.render(reactElement, domContainer)是指：“亲爱的 React，使 domContainer 的 Host 树与我的 reactElement 匹配吧。” React 将查看reactElement.type（在我们的示例中为'button'），并要求 React DOM 渲染器为其创建 Host 实例并设置属性： 123456// Somewhere in the ReactDOM renderer (simplified)function createHostInstance(reactElement) &#123; let domNode = document.createElement(reactElement.type); domNode.className = reactElement.props.className; return domNode;&#125; 在示例中，有效的 React 将做到如下： 123let domNode = document.createElement('button');domNode.className = 'blue';domContainer.appendChild(domNode); 如果 React 元素在reactElement.props.children中有子元素，React 也将在第一次呈现时为它们递归创建 Host 实例。 调停 Reconciliation 如果我们用同一容器两次调用ReactDOM.render()会如何呢？ 123456789101112ReactDOM.render( &lt;button className="blue" /&gt;, document.getElementById('container'),);// ... later ...// 这应该*替换*按钮的Host实例么，或者只更新现有属性上的值？ReactDOM.render( &lt;button className="red" /&gt;, document.getElementById('container'),); 同样，React 的工作就是使 Host 树与提供的 React 元素树匹配。为了响应新的信息而弄清楚 Host 实例树要做什么的过程，被称为调停。 有两个方法可以解决这个问题，简化版的 React 可以讲现有的树清理并重建： 1234567let domContainer = document.getElementById('container');// 清理树domContainer.innerHTML = '';// 新建Host实例树let domNode = document.createElement('button');domNode.className = 'red';domContainer.appendChild(domNode); 但这在 DOM 中会很慢，并且会丢失很重要的信息，如焦点、选中、滚动状态等。而我们希望 React 可以这样： 123let domNode = domContainer.firstChild;// 更新现有的Host实例domNode.className = 'red'; 换句话说，React 需要决定何时对现有 Host 实例进行更新以匹配新的 React 元素，以及何时创建新的元素。 这引发了一个关于身份识别的问题。React 元素每次都可能不同，但它什么时候在概念上引用同一个 Host 实例呢？ 在简单示例中，我们曾将一个&lt;button&gt;呈现为第一个（也是唯一）子元素，我们希望再次在同位上呈现一个&lt;button&gt;。现在已经有了一个&lt;button&gt;的 Host 实例，那么为什么要重建它呢？我们应该复用它才对。 这很接近人们对 React 的想法。 如果树中同位的元素类型在前后渲染之间“匹配”，那么 React 将重用现有的 Host 实例。 以下是一个示例，其中的注释大致显示了 React 的作用： 1234567891011121314151617181920212223242526// let domNode = document.createElement('button');// domNode.className = 'blue';// domContainer.appendChild(domNode);ReactDOM.render( &lt;button className="blue" /&gt;, document.getElementById('container'));// 可以重用Host实例吗? Yes! (button → button)// domNode.className = 'red';ReactDOM.render( &lt;button className="red" /&gt;, document.getElementById('container'));// 可以重用Host实例吗? No! (button → p)// domContainer.removeChild(domNode);// domNode = document.createElement('p');// domNode.textContent = 'Hello';// domContainer.appendChild(domNode);ReactDOM.render( &lt;p&gt;Hello&lt;/p&gt;, document.getElementById('container'));// 可以重用Host实例吗? Yes! (p → p)// domNode.textContent = 'Goodbye';ReactDOM.render( &lt;p&gt;Goodbye&lt;/p&gt;, document.getElementById('container')); 可以用同样的方式探索子树。例如，当我们用两个&lt;button&gt;更新一个&lt;dialog&gt;时，React 首先决定是否重新使用&lt;dialog&gt;，然后为每个子元素重复次决策过程。 条件 Conditions 如果 React 仅在更新之间的元素类型“匹配”时重用 Host 实例，那么会如何呈现条件内容？ 假设我们只是想首先显示一个输入，但稍后在它之前呈现一条消息： 123456789101112131415// First renderReactDOM.render( &lt;dialog&gt; &lt;input /&gt; &lt;/dialog&gt;, domContainer,);// Next renderReactDOM.render( &lt;dialog&gt; &lt;p&gt;I was just added here!&lt;/p&gt; &lt;input /&gt; &lt;/dialog&gt;, domContainer,); 示例中，&lt;input&gt;的 Host 实例将被重建，React 将遍历元素树，与其上一版本进行比较： dialog → dialog：可以重用 Host 实例么？是的——类型匹配。 input → p：可以重用 Host 实例么？**不是，类型已改变！**需要删除现有的input并创建新的pHost 实例。 (nothing) → input：需要创建一个新的inputHost 实例。 因此，React 执行的更新代码实际上是： 12345678let oldInputNode = dialogNode.firstChild;dialogNode.removeChild(oldInputNode);let pNode = document.createElement('p');pNode.textContent = 'I was just added here!';dialogNode.appendChild(pNode);let newInputNode = document.createElement('input');dialogNode.appendChild(newInputNode); 这并不好，因为概念上的&lt;input&gt;没有被&lt;p&gt;替换——它只是被移动了。我们并不想因为重建 DOM 而丢失它的选中、焦点状态和内容。 虽然这个问题有一个简单的解决方法（我们将在一分钟内解决），但在 React 应用程序中并不经常发生。这其中的原因很有趣。 实际上，你很少直接调用ReactDOM.render。相反，React 应用程序往往被分解成如下功能： 123456789101112function Form(&#123; showMessage &#125;) &#123; let message = null; if (showMessage) &#123; message = &lt;p&gt;I was just added here!&lt;/p&gt;; &#125; return ( &lt;dialog&gt; &#123;message&#125; &lt;input /&gt; &lt;/dialog&gt; );&#125; 这个例子不受我们刚才描述的问题的影响，如果我们使用对象表示法而不是 JSX，可能更容易理解为什么会这样。以下是dialog的子元素树： 123456789101112131415function Form(&#123; showMessage &#125;) &#123; let message = null; if (showMessage) &#123; message = &#123; type: 'p', props: &#123; children: 'I was just added here!' &#125;, &#125;; &#125; return &#123; type: 'dialog', props: &#123; children: [message, &#123; type: 'input', props: &#123;&#125; &#125;], &#125;, &#125;;&#125; 无论showMessage的值是true或false，&lt;input&gt;是第二个子元素，在渲染之间不会更改其树的位置。 如果showMessage的值从false变为true，那么 React 将遍历元素树，并将其与以前的版本进行比较： dialog → dialog：可以重用 Host 实例么？是的——类型匹配。 (null) → p：需要插入新的pHost 实例。 input → input：可以重用 Host 实例么？是的——类型匹配。 由 React 执行的代码类似于： 1234let inputNode = dialogNode.firstChild;let pNode = document.createElement('p');pNode.textContent = 'I was just added here!';dialogNode.insertBefore(pNode, inputNode); 这就没有输入状态的丢失。 列表 Lists 比较树中同位的元素类型通常足以决定是否重用或重建相应的 Host 实例。 但是只有当子节点的位置是静态的，不会重新排序时才有效。在上面的示例中，即使message可能是一个“hole”，我们仍然知道在输入消息后并没有其他的子级。 对于动态列表，我们无法确定顺序是否始终相同： 12345678910111213function ShoppingList(&#123; list &#125;) &#123; return ( &lt;form&gt; &#123;list.map((item) =&gt; ( &lt;p&gt; You bought &#123;item.name&#125; &lt;br /&gt; Enter how many do you want: &lt;input /&gt; &lt;/p&gt; ))&#125; &lt;/form&gt; );&#125; 如果我们的购物项目的list被重新排序，React 将看到其中的所有的p和input元素具有相同的类型，并且不知道移动它们。（从 React 的角度来看，每一个子元素都发生了变化，而不是顺序。） React 执行的代码像下面这样重新添加了十个子元素： 12345for (let i = 0; i &lt; 10; i++) &#123; let pNode = formNode.childNodes[i]; let textNode = pNode.firstChild; textNode.textContent = 'You bought ' + items[i].name;&#125; 因此，React 不会对它们进行重新排序，而是有效地对它们每个进行更新。这会造成性能问题和可能的错误。例如，第一个输入的内容将在排序后的第一个输入中保持不变——即使在概念上它们可能指代list中的不同对象。 这就是为什么每次在输出中包含元素数组时，React 都会要求你指定一个名为 key 的特殊属性： 1234567891011121314function ShoppingList(&#123; list &#125;) &#123; return ( &lt;form&gt; &#123;list.map((item) =&gt; ( &lt;p key=&#123;item.productId&#125;&gt; &#123;' '&#125; You bought &#123;item.name&#125; &lt;br /&gt; Enter how many do you want: &lt;input /&gt; &lt;/p&gt; ))&#125; &lt;/form&gt; );&#125; 一个key告诉 React 它应该在概念上认为一个项是相同的，即使它在两个呈现之间的父元素中有不同的位置。 当 React 在一个&lt;form&gt;中看到&lt;p key=&quot;42&quot;&gt;时，它将检查上一个渲染是否也包含&lt;p key=&quot;42&quot;&gt;在同一个&lt;form&gt;中。即使子节点改变了顺序，这也将起作用。React 将重用具有相同密钥的前一个 Host 实例（如果存在），并相应地在同级重新排序。 请注意，key只与特定的父级 React 元素相关，例如&lt;form&gt;。React 不会尝试在不同的父元素之间使用相同的键“匹配”元素。（React 不支持在不同的父元素之间移动 Host 实例而不重建它。） 什么事好的key值呢？回答这个问题的一个简单方法是问：**即使订单改变，对于你来说什么一定是“相同的”？**例如，在我们的购物清单中，产品 ID 在其间是一个唯一的标识。 组件 Components 这是返回 React 元素的函数： 123456789101112function Form(&#123; showMessage &#125;) &#123; let message = null; if (showMessage) &#123; message = &lt;p&gt;I was just added here!&lt;/p&gt;; &#125; return ( &lt;dialog&gt; &#123;message&#125; &lt;input /&gt; &lt;/dialog&gt; );&#125; 它们被称为组件。它们让我们创建自己的“组件库”，包括按钮、头像、评论等。组件对于 React 来说就像是面包之于黄油——是不可或缺的。 组件接受一个参数——一个 hash 的对象，它包括“props”（属性“properties”的缩写）。showMessage就是这样一个prop，它们像是参数一样的命名。 纯度 Purity 假设 React 的组件相对于它们的props是纯粹的。 1234function Button(props) &#123; // 🔴 Doesn't work props.isActive = true;&#125; 一般来说，变化不是 React 擅长的。（稍候我们将进一步讨论更新 UI 以响应事件的常用方法。） 不过，内部变化显然是个不错的选项： 12345678function FriendList(&#123; friends &#125;) &#123; let items = []; for (let i = 0; i &lt; friends.length; i++) &#123; let friend = friends[i]; items.push(&lt;Friend key=&#123;friend.id&#125; friend=&#123;friend&#125; /&gt;); &#125; return &lt;section&gt;&#123;items&#125;&lt;/section&gt;;&#125; 我们在渲染时创建了items没有其他组件会“看到”它，因此我们可以在将其作为渲染结果的一部分在传递之前根据自己的需要对其进行更改。没有必要为了避免内部变化而更改代码，让代码变得扭曲。 同样，尽管没有完全“纯粹的”初始化，但是延迟初始化也是可以的： 123456function ExpenseForm() &#123; // Fine if it doesn't affect other components: SuperCalculator.initializeIfNotReady(); // Continue rendering...&#125; 只要多次调用一个组件是安全的并不影响其他组件的呈现，React 就不关心它是否在 strict FP Sense 上是 100%纯粹的。等幂Idempotence对 React 比是否纯粹更重要。 也就是说，React 组件中不允许有用户直接可见的副作用。换句话说就是仅仅调用一个组件函数本身就不该在屏幕上发生变化。 递归 Recursion 我们如何使用其他组件的组件？组件本质是函数，所以我们可以调用它们： 12let reactElement = Form(&#123; showMessage: true &#125;);ReactDOM.render(reactElement, domContainer); 但是这不是在 React 运行时使用组件的常用方法。 相反，使用组件的常用方法与我们以前见过的机制相同——React 元素。这意味着你不用直接调用组件函数，而是让 React 稍后为你执行： 123// &#123; type: Form, props: &#123; showMessage: true &#125; &#125;let reactElement = &lt;Form showMessage=&#123;true&#125; /&gt;;ReactDOM.render(reactElement, domContainer); 在 React 某处，你的组件会被称为： 1234// Somewhere inside Reactlet type = reactElement.type; // Formlet props = reactElement.props; // &#123; showMessage: true &#125;let result = type(props); // Whatever Form returns 组件函数名称按约定应当大写，当 JSX 转换时看到&lt;Form&gt;而不是&lt;form&gt;时，它使对象本身成为标识符而不是字符串： 12console.log(&lt;form /&gt;.type); // 'form' stringconsole.log(&lt;Form /&gt;.type); // Form function 没有全局注册机制——键入&lt;Form /&gt;时我们按名称逐字地引用Form，如果本地作用域中不存在Form，你将看到一个 JavaScript 错误，就像通常使用错误变量名时一样。 好了，那么当一个元素类型是一个函数时，React 会干什么呢？它调用组件并询问组件希望呈现什么元素。 这个过程将以递归的方式继续，并在此处。简而言之它看起来会是这样： You: ReactDOM.render(&lt;App /&gt;, domContainer) React: Hey App，你要呈现什么？ App：我想呈现&lt;Layout&gt;且包含&lt;Content&gt;子元素。 React: Hey Layout，你要呈现什么？ Layout：我想在&lt;div&gt;中呈现我的子元素。我的子元素是&lt;Content&gt;，所以我才需要进入&lt;div&gt;。 React: Hey &lt;Content&gt;，你要呈现什么？ Content：我想呈现&lt;article&gt;包含Some text和一个&lt;Footer&gt;子元素。 React: Hey &lt;Footer&gt;，你要呈现什么？ Footer：我想呈现一个&lt;footer&gt;和some more text。 React: 好的现在就去： 1234567// Resulting DOM structure&lt;div&gt; &lt;article&gt; Some text &lt;footer&gt;some more text&lt;/footer&gt; &lt;/article&gt;&lt;/div&gt; 这就是为什么我们说调停是递归的，当 React 遍历元素树时，它可能会遇到type是组件的元素，调用它并继续沿着返回的 React 元素树下降。最终穷尽所有的组件，React 也会知道 Host 树中要改变什么。 我们已经讨论过相同调停规则也适用于这里。如果同位的type（由索引和可选的key）发生更改，React 将丢弃其中的 Host 实例，并重建它们。 控制反转 Inversion of Control 你可能会想：我们为什么不直接调用组件？为什么要写&lt;Form /&gt;而不是Form()？ 如果 React 知道你的组件，而不是在递归调用后只看到 React 元素树，那么它可以做得更好。 123456789101112// 🔴 React不知道 Layout 和 Article 存在。// 你可以调用它们。ReactDOM.render(Layout(&#123; children: Article() &#125;), domContainer);// ✅ React知道 Layout 和 Article 存在。// React可以调用它们。ReactDOM.render( &lt;Layout&gt; &lt;Article /&gt; &lt;/Layout&gt;, domContainer,); 这是控制反转的经典示例。通过让 React 控制调用组件，我们可以获得一些有趣的特性： 组件变得不仅仅是函数。React 可以使用与树中组件标识相关的内部状态等功能来扩充组建函数。一个好的运行时提供了与手头问题相匹配的基本抽象。正如我们已经提到的，React 是专门面向那些呈现 UI 树并响应交互的程序的。如果直接调用组件，则必须自己构建这些特性。 组件类型参与调停。通过让 React 调用你的组件，你还可以告诉它有关树的概念结构的更多信息。例如，当你从渲染&lt;Feed&gt;移动到&lt;Profile&gt;页面时，React 不会尝试复用其中的 Host 实例——就像你将&lt;button&gt;替换为&lt;p&gt;一样，所有的状态都将消失——当呈现概念上不同的视图时，这通常很棒，即使树中的&lt;input&gt;位置意外的在它们之间“排队”，你也不希望在&lt;PasswordForm&gt;和&lt;MessengerChat&gt;上保留输入状态。 React 可以延迟调停。如果 React 控制调用我们的组件，它可以做许多有趣的事情。例如，它可以让浏览器在组件调用之间做一些工作，以便我们重新呈现一个大型组件树时不阻塞主线程。在不重新实现大部分 React 的时候，手动协调达成这是很困难的。 更好地调试。如果组件是库可以识别的（类型），我们可以构建富开发工具一边在开发中自查。 响应组件函数的最后一个好处是lazy evaluation，让我们看看这是什么意思。 懒测评 Lazy Evaluation 当我们在 JavaScript 中调用函数时，参数会在调用之前进行计算： 12345// (2) This gets computed secondeat( // (1) This gets computed first prepareMeal(),); 这通常是 JavaScript 开发人员所期望的，因为 JavaScript 函数可能有隐含的副作用，如果我们调用一个函数，它的结果在 JavaScript 某种方法被“使用”之后才出现，就太过出乎人的意料了。 但是，React 组件是[相对][purity]纯粹的。如果我们知道它的结果不会在屏幕上呈现，就完全没有必要执行它。 考虑将&lt;Comments&gt;放在&lt;Page&gt;的组件中： 1234567891011121314function Story(&#123; currentUser &#125;) &#123; // return &#123; // type: Page, // props: &#123; // user: currentUser, // children: &#123; type: Comments, props: &#123;&#125; &#125; // &#125; // &#125; return ( &lt;Page user=&#123;currentUser&#125;&gt; &lt;Comments /&gt;&#123;' '&#125; &lt;/Page&gt; );&#125; Page组件可以在某些Layout中呈现给他的子组件： 123function Page(&#123; currentUser, children &#125;) &#123; return &lt;Layout&gt;&#123;children&#125; &lt;/Layout&gt;;&#125; (在 JSX 中等同于&lt;A children={} /&gt;.) 但如果它有条件提前退出呢？ 123456function Page(&#123; currentUser, children &#125;) &#123; if (!currentUser.isLoggedIn) &#123; return &lt;h1&gt;Please login&lt;/h1&gt;; &#125; return &lt;Layout&gt;&#123;children&#125;&lt;/Layout&gt;;&#125; 如果我们将Comments()作为函数使用，它将立即执行而不理会Page是否要呈现给它们： 123456// &#123;// type: Page,// props: &#123;// children: Comments() // Always runs!// &#125;// &#125;&lt;Page&gt;&#123;Comments()&#125;&lt;/Page&gt; 但是，如果我们传递一个 React 元素，而根本就不执行Comments： 12345678// &#123;// type: Page,// props: &#123;// children: &#123; type: Comments &#125;// &#125;// &#125;&lt;Page&gt; &lt;Comments /&gt;&lt;/Page&gt; 这让 React 决定何时和是否调用它，如果我们的Page组件忽略了它的children属性并呈现了&lt;h1&gt;Please login&lt;/h1&gt;相反，React 甚至不会调用Comments函数，有什么意义么？ 这很好，因为这两种方法都可以避免不必要的渲染，从而减少代码的脆弱性。（当用户注销时，我们不在乎Comments是否引发，它不会被调用。） 状态 State 我们之前 说过关于表示以及元素在树中的概念“位置”如何告诉 React 是复用 Host 状态还是创建新的实例。Host 实例可以具有各种内部状态：焦点、选中、输入等。我们希望在概念上呈现相同 UI 的更新之间保留此状态。我们还希望在呈现概念上不同的东西时（例如从&lt;SignupForm&gt;移动到&lt;MessengerChat&gt;），可以有预见的破坏它。 内部状态非常有用，因此 React 让你自己的组件也拥有这个功能。组件仍然是函数，但 React 会使用对 UI 有用的功能来增强它们，与树中的位置相关联的内部状态就是这样的特性之一。 我们称这些特性为Hooks。例如，useState就是一个 Hook. 123456789function Example() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;&#123;' '&#125; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me&lt;/button&gt; &lt;/div&gt; );&#125; 它返回一对值：当前状态和更新它的函数。 解构数组语法允许我们为状态变量指定任意名称。例如，我称这对为count和setCount，但它可能是banana和setBanana。在下面的文本中，我将使用setState引用第二个值，而不管在特定示例中它的实际名称是什么。 （你可以在这里了解更多关于 useState 和 React 提供的其他的 Hook 的信息） 一致性 Consistency 即使我们想将调停过程本身拆分为非阻塞工作块，我们仍然应该在一个同步解析（swoop）中执行实际的 Host 树操作。这样我们就可以确保用户不会看到半更新的用户界面，并且浏览器不会对用户不应该看到的中间状态执行不必要的布局和样式重新计算。 这就是 React 将所有的工作拆分为“渲染阶段”和“提交阶段”的原因。渲染阶段是当 React 调用组件并执行协调时，中断是安全的，并且在未来将是异步的。提交阶段是当 React 接触到 Host 树时，它一直会是同步的。 记忆化 Memoization 当父组件通过调用setState来调度更新时，默认情况下，React 会协调其整个子树。这是因为 React 不知道父组件中的更新是否会影响整个子树，默认情况下 React 选择一致，这听起来代价很昂贵，但实际上对于中小型子树来说，这并不是问题。 当树变得层级过深或者太宽时，你可以告诉 React 去记忆子树，并在稍微相等的属性更改期间重用以前的呈现结果： 12345function Row(&#123; item &#125;) &#123; // ...&#125;export default memo(Row); 现在，父级&lt;Table&gt;组件中的setState将跳过调停item与上次呈现相等的item的Row。 你可以使用useMemo()这个 Hook在单个表达式级别上获得细颗粒度的记忆。缓存是组件树位置的内部缓存，将于其内部状态一同销毁，它只保存最后一个项目。 默认情况下，React 会故意不记忆组件，许多组件总是受到不同的props，因此记忆它们是一个净损失。 原始模型 Raw Models 更具有讽刺意味的是，React 不使用“反应性（reactivity）”系统进行细粒度的更新，换句话说就是顶部的任何更新都会触发调节，而不只是更新受更改影响的组件。 这是一个意向性设计决策。交互时间是面向用户 Web 应用程序中的一个重要指标，遍历模型已设置细粒度侦听器将花费宝贵的时间。此外在许多应用程序中，交互往往会导致小的（按钮悬停）或大的（页面跳转）更新，在这种情况下，细粒度订阅浪费了内存资源。 React 的核心设计原则之一就是它与原始数据一同工作，如果从网络中接收到大量的 JavaScript 对象，则可以直接将它们推入组件中，而不需要进行预处理。对于你可以访问那些属性，或者当结构发生发生轻微变化时出现意外的性能断崖，目前尚不明确，React 渲染复杂度是 O(视图大小)而不是 O(模型大小)，你可以使用窗口化显著地减少视图大小。 有些应用程序的细粒度订阅是有益的，比如股票行情。这是个罕见的例子，“所有的东西都在同时更新”。尽管命令式转义图案填充可以帮助优化此类代码，但 React 可能并不适合此用例。不过，你可以在 React 上实现自己的细粒度订阅系统。 请注意，有一些常见的性能问题，即使是细粒度订阅和“反应性”系统也无法解决。例如，在不阻塞浏览器的情况下呈现一个新的深树（发生在每个页面转换中）。更改跟踪并不能使其更快——这只会拖慢它，因为我们必须做更多来设置订阅。另一个问题是，在开始呈现视图之前，我们必须等待数据。在 React 中，我们的目标是通过并发渲染来解决这两个问题。 配料 Batching 多个组件可能希望更新状态以响应同一事件。这个例子很复杂，但它说明了一个常见的模式： 1234567891011121314151617181920function Parent() &#123; let [count, setCount] = useState(0); return ( &lt;div onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; &#123;' '&#125; Parent clicked &#123;count&#125; times &lt;Child /&gt; &lt;/div&gt; );&#125;function Child() &#123; let [count, setCount] = useState(0); return ( &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; &#123;' '&#125; Child clicked &#123;count&#125; times &lt;/button&gt; );&#125; 调度事件时，首先激发子组件的onClick（触发其setState）。然后，父组件在自己的onClick处理器中调用setState。 如果 React 立即重新呈现组件以响应setState调用，则最终将呈现子组件两次： 1234567*** Entering React's browser click event handler ***Child (onClick) - setState - re-render Child // 😞 unnecessaryParent (onClick) - setState - re-render Parent - re-render Child*** Exiting React's browser click event handler *** 第一个Child渲染将被浪费，我们不能让 React 跳过第二次呈现Child，因为Parent可能会根据它的更新状态向它传递一些不同的数据。 这就是为什么在事件处理程序中进行 React 的批次处理更新： 123456789*** Entering React's browser click event handler ***Child (onClick) - setStateParent (onClick) - setState*** Processing state updates *** - re-render Parent - re-render Child*** Exiting React's browser click event handler *** 组件中的setState调用不会立即导致重新呈现。相反，React 会将首先执行所有时间处理程序，然后触发一个重新渲染批处理所有这些更新。 批处理有助于提高性能，但如果编写以下代码，你会感到惊讶： 1234567891011const [count, setCounter] = useState(0);function increment() &#123; setCounter(count + 1);&#125;function handleClick() &#123; increment(); increment(); increment();&#125; 如果我们以count设置为0开头，那么这将是三个setCount(1)调用。要解决这个问题，setState提供接受“updater”函数的重载： 1234567891011const [count, setCounter] = useState(0);function increment() &#123; setCounter((c) =&gt; c + 1);&#125;function handleClick() &#123; increment(); increment(); increment();&#125; React 会将更新程序函数放在队列中，然后按顺序运行它们，从而导致count设置为3的重新呈现。 当状态逻辑比几个setState调用更复杂时，我建议使用useReducer这个 Hook将其表示为本地状态还原程序。这就像是这种“更新程序”模式的演变，每个更新都有一个名称： 1234567891011const [counter, dispatch] = useReducer((state, action) =&gt; &#123; if (action === 'increment') &#123; return state + 1; &#125;&#125;, 0);function handleClick() &#123; dispatch('increment'); dispatch('increment'); dispatch('increment');&#125; 尽管对象是常见的选择，action参数却可以是任何东西。 调用树 Call Tree 编程语言运行时通常有一个调用堆栈。当函数a()调用b()，它本身调用c()，在 JavaScript 引擎的某个地方有一个类似于[a, b, c]的数据结构，它“跟踪”你所在的位置以及下一步要执行的代码。一旦退出c，它的调用堆栈帧就消失了——噗！它不再需要了。我们跳回到b中。当我们退出a时，调用堆栈就已经空了。 当然，React 本身在 JavaScript 中运行并遵守 JavaScript 规则，但我们可以想象，React 内部有自己的调用堆栈来记住我们当前正在呈现的组件，例如：[App, Page, Layout, Article /* we're here */]。 React 与通用语言运行时不同，因为它旨在呈现 UI 树，这些树需要“保持活性”，这样我们才能与它们互动。在第一次调用ReactDOM.render()后，DOM 不会消失。 这可能是一个延伸的比喻，但我喜欢把 React 组件看作是在一个“调用树”而不是“调用堆栈”。当我们“走出”Article组件的时候，React 的“调用树”框架不会被破坏。我们需要保持内部状态和对 Host 实例某处的引用。 这些“调用树”帧连同它们的内部状态和 Host 实例一同被销毁但仅当调停规则认为这是必要的时候。如果你读过 React 的源码，你可能会看到这些帧被称为纤维 Fibers。 纤维是内部状态实际生存的地方，当状态更新的时候，React 将下面的纤维标记为需要协调，并调用这些组件。 上下文 Context 在 React 中，我们将东西作为 prop 传递给其他组件。有时，大多数组件需要相同的东西——例如，当前选择的视觉主题。通过每一层传递就很麻烦。 在 React 中，这由上下文解决。它本质上类似于组件的动态范围。就好像一个虫洞，让你把东西放在顶端，让底部的每个子节点都可以阅读它，并且在它改变时重新渲染。 1234567891011121314151617const Theme = React.createContext( 'light' // Default value as a fallback);function DarkApp() &#123; return ( &lt;Theme.Provider value="dark"&gt; &lt;MyComponents /&gt; &lt;Theme.Provider&gt; );&#125;function SomeDeeplyNestedChild() &#123; // Depends on where the child is rendered const theme = useContext(Theme); // ...&#125; 当SomeDeeplyNestedChild呈现时，useContext(Theme)将在树中查找其上方最近的&lt;ThemeContext.Provider&gt;，并使用其value。 （实际上，React 在渲染时维护上下文堆栈。） 如果上面没有ThemeContext.Provider则useState(ThemeContext)调用的结果将是createContext()调用中指定的默认值，在我们的示例中，它是'light'。 作用 Effects 我们之前提到过的，在渲染过程中，React 组件不应该有明显的副作用，但是副作用是有时是必要的。我们可能需要管理焦点、绘制画布、订阅数据源等等。 在 React 中，这是通过声明一个效果来实现的： 12345678910111213function Example() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; );&#125; 如果可能，React 会延迟执行作用，直到浏览器重绘屏幕。这很好，因为像数据源订阅这样的代码不应损害交互时间和首次绘图时间。（有一个很少使用的 Hook 可以让你选择退出这种行为，并同步执行，请尽可能避开它。） 作用不止运行一次，它们是在第一次向用户显示组件之后以及在组件更新之后运行。作用可以关闭当前的 props 和 state，如上面的示例中的count。 作用可能需要清除，例如在订阅情况下，要在自身之后清楚，作用可以返回函数： 1234useEffect(() =&gt; &#123; DataSource.addSubscription(handleChange); return () =&gt; DataSource.removeSubscription(handleChange);&#125;); React 将在下次应用此作用之前执行返回的函数，也将在销毁组件之前执行。 有事，在每个渲染上重新运行作用可能实不可取的，如果某些变量没有改变，你可以告诉 React 去跳过应用作用： 123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]); 但是，这通常是一个早期的优化，如果你不熟悉 JavaScript 的闭包工作方式，可能会导致问题。 例如此代码是错误的：： 1234useEffect(() =&gt; &#123; DataSource.addSubscription(handleChange); return () =&gt; DataSource.removeSubscription(handleChange);&#125;, []); 这个错误是因为[]表示“永远不要在执行这个作用”，但这个作用结束于外部定义的handleChange，和handleChange可以引用任何 props 或 state： 123function handleChange() &#123; console.log(count);&#125; 如果不让作用重新运行，handleChange将继续指向第一次呈现的版本，count将始终位于其中0。 要解决这个问题，请确保如果你指定依赖数组，它包括所有可以更改的内容，包括函数： 1234useEffect(() =&gt; &#123; DataSource.addSubscription(handleChange); return () =&gt; DataSource.removeSubscription(handleChange);&#125;, [handleChange]); 根据代码的不同，你可能任然会看到不必要的重新订阅，因为handleChange本身在每个渲染中都是不同的。useCallback Hook 可以帮助你实现这一点，或者你可以让它重新订阅。例如，浏览器的addEventListenerAPI 速度非常快，为了避免调用它而跳过循环，可能会导致比它导致更多的问题。 （你可以在这里了解更多关于 useEffect 和 React 提供的其他 Hooks 的信息。） 自定义 Hooks 由于像useState和useEffect这样的 Hook 是函数调用的，我们可以将它们组合成自己的 Hooks： 12345678910111213141516function MyResponsiveComponent() &#123; const width = useWindowWidth(); // Our custom Hook return ( &lt;p&gt;Window width is &#123;width&#125;&lt;/p&gt; );&#125;function useWindowWidth() &#123; const [width, setWidth] = useState(window.innerWidth); useEffect(() =&gt; &#123; const handleResize = () =&gt; setWidth(window.innerWidth); window.addEventListener('resize', handleResize); return () =&gt; &#123; window.removeEventListener('resize', handleResize); &#125;; &#125;); return width;&#125; 自定义 Hooks 允许不同的组件共享可复用的状态逻辑。注意，state 本身不是共享的，对 Hook 的每个调用都声明自己的独立 state。 （你可以在这里学到更多关于自定义 Hooks 的知识。） 静态使用顺序 你可以将useState视为定义“React state 变量”的语法。当然，这里不是一种真正的语法，我们还在写 JavaScript，但是我们将 React 视为一个运行时环境，因为 React 将 JavaScript 裁剪为描述 UI 树，所以它的特性有时更接近语言空间。 如果use是一种语法，那么它处于顶层是有意义的： 123456789101112// 😉 Note: not a real syntaxcomponent Example(props) &#123; const [count, setCount] = use State(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 将其放入调节、回调或组件外部意味着什么？ 12345678910111213141516// 😉 Note: not a real syntax// This is local state... of what?const [count, setCount] = use State(0);component Example() &#123; if (condition) &#123; // What happens to it when condition is false? const [count, setCount] = use State(0); &#125; function handleClick() &#123; // What happens to it when we leave a function? // How is this different from a variable? const [count, setCount] = use State(0); &#125; React 的 state 是组件及其在树中的表示的内部状态。如果use是一个真正的语法，那么将其范围也限定到组件的顶层是有意义的： 123456789// 😉 Note: not a real syntaxcomponent Example(props) &#123; // Only valid here const [count, setCount] = use State(0); if (condition) &#123; // This would be a syntax error const [count, setCount] = use State(0); &#125; 这类似于import只在模块顶层工作。 当然，使用实际上不是一种语法。 （它不会带来太大的好处，也不造成很多损耗。） 但是，React确实期望所有的钩子的调用都只在组件的顶层无条件地发生。这些Hooks 规则可以通过一个 lint 插件强制执行。关于这一设计选择，一直有激烈的争论，但在实践中，我并未发现有何不妥，同样我还写了为什么通常建议的替代方案不起作用。 在内部，Hooks 被实现为链表。当你调用useState时，我们将指针移动到下一个节点上，当我们退出组件的“调用”帧，我们将结果列表保存在哪里，知道下一次呈现。 本文提供了 Hooks 如何在内部工作的简化解释，数组可能比链表更容易成为一个构想模型： 12345678910111213141516171819// Pseudocodelet hooks, i;function useState() &#123; i++; if (hooks[i]) &#123; // Next renders return hooks[i]; &#125; // First render hooks.push(...);&#125;// Prepare to renderi = -1;hooks = fiber.hooks || [];// Call the componentYourComponent();// Remember the state of Hooksfiber.hooks = hooks; （如果你好奇，解码就在这里。If you’re curious, the real code is here.） 这大致就是每个useState()调用获得正确 state 的方式。正如我们之前所提到的,“匹配事物”并非 React 的新特性——调停依赖于类似匹配元素渲染这样的方法。 后续 我们已经讨论了 React 运行时环境几乎所有重要的方面，如果你读完应该会知道 React 中 90%以上的细节，这你可以放心！ 我遗留了一些部分——连我们都不太清晰。React 目前对于多路径渲染没有一个很好的阐述，例如当父级渲染需要有关子级的信息时。此外，错误处理 API还没有 Hooks 版本。这两个问题有可能之后被一同解决。并发模式下还不稳定，有一些有趣的问题类似 Suspense 是怎么嵌入这个路线图的。也许我们会在后续使其功能更加丰富，Suspense 已经准备好进行懒加载了。 我认为这说明了 React 的 API 的成功，你可以在不考虑大多数主题的情况下取得很大的进展。大多数情况下，良好的默认值（如调停启发式算法）都是正确的。当你使用危险的方案时，key这类警告也会对你敲打。 如果你是一个 UI 库的维护者，我希望这篇文章会有作用，并且更深入地阐明 React 的工作方式，或者你觉得 React 太过复杂决心剔除。不管哪种情况我都很期待在 Twitter 上了解你的见解！谢谢您的阅读！ Discuss on Twitter • Edit on GitHub 原文链接： React as a UI Runtime]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMAScript</tag>
        <tag>Web开发</tag>
        <tag>框架</tag>
        <tag>性能</tag>
        <tag>译文</tag>
        <tag>React</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[年前一些随笔]]></title>
    <url>%2Farchives%2Froutine-life%2Fessay%2F1549180675.html</url>
    <content type="text"><![CDATA[年关将至，过年的氛围却已经在不觉中被接踵而至的事情冲淡了，可能是上火车前的大扫除，也可能是春运火车上窒息般的体验、恶劣的吸烟乘客，又或是刚刚回到武汉对寒冷的不适…… 作为一个对烟味敏感的人，任何二手烟场合我都觉得是遭受了暴力攻击，更何况是小姐姐劝说不要在公告场合吸烟，却还要恶语相向、脏话连篇的烟鬼，哪怕是在年关也不该让这种恶人逃脱制裁！！ 不过现在可能只是在想关于我的姥姥，早上在下了火车就去了医院，在病榻前看到了她已经不成形的身体。为什么今年没有早点回家，来看看她，现在后悔却也只能看到她年迈体虚、恶疾缠身的状态，生存对于她开始变得艰难，仿佛尽头就在前方，却还在勉力支撑自己向前，再多留下些时日，多看看这个世界，希望自己能挺过这个年关。 今天还有机会看到她，我只能说自己是幸运的，感慨其意志之坚的同时，也觉得自己何其不孝。爷爷走的时候我还小，在外上课没有人告知我，两个月之后知道的时候，却依旧没能立刻动身前去扫墓；姥爷走的时候，我又在学校补课，没能顾上最后一面，火化的时候怔怔的站在人群之后；然而这一次我也是差点因为工作错过，下火车的时候得知了实情后，才去了医院。意志之中有怎样的韧性才能使人在脱了形之后还能抓着手呢喃低语，身体在怎样的病痛之后才会似若无骨、绵软无力，这次我可能就看到了吧。 临别远比单纯的悼念来的刻骨，这样的过程会比扫墓更能铭心。我不知道还能有多久，还会有多少时日，但这次我真切的感受到了生命的脆弱，面对大恐惧时的不堪和无助，也更加理解了所谓珍惜应当如何，生命的错过不可能读档。 可能曾经的几次错过对于我来说，是无知也是无心之失，却也在心中一直抱憾，那这一次我希望自己虽然已经迟到，但在剩下的时间中，还可以多陪陪她，在最后的日子中，希望她能感受到病痛之外，我们这些家人都在。 离别不会是终点，生命若圆，始终如一，祈来去波澜不惊，愿生命无遗无憾。]]></content>
      <categories>
        <category>生活</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 React.lazy() 和 Suspense 提高React应用程序的性能]]></title>
    <url>%2Farchives%2Ffront-end%2Fframe%2FReact%2F1546835543.html</url>
    <content type="text"><![CDATA[Lazy loading💤 已经成为被广泛应用于加载提速的优化技术之一。延迟加载的前景有助于将某些 web app 出现程序性能问题的风险降至最低〽。 在本文中，我们将研究如何使用 Lazy loading💤 来优化 React 应用程序中的加载时间。 什么是 Lazy Loading💤？ 懒加载是一种优化技巧 💫 我们通过延迟对象(图片 🎦, 视频 🎬, 网页 🌎, 音乐 🎶, 文档 📋) 加载直到他们被使用。 当用户打开一个页面，所有的内容将一次性下载下来。大多数内容可能永远也不会发生作用或者被用户看见。所以为什么要浪费宝贵的资源和带宽呢？ 为了提高我们网站的响应时间，我们选择延迟加载一些应用程序中的非关键部分。当用户需要访问这些部分的时候，再加载这些资源。 SSR, CSR 和 React 我们有 SSR(server-side rendered / 服务端呈现)应用程序和 CSR(Client side rendered / 客户端呈现)应用程序。 SSR 是使用.HTML 构建的优秀传统页面，可以选择配合 ASP.NEt 或是 PHP 等来使用。每个连接都有一个不同的.HTML 文件需要加载。 12345web-app/ - index.html - about.html - faq.html - careers.html 每个页面都要记载不同的 HTML 文件。 随着 JS 框架的出现，网页被浑河成为一个单独的 js 并一次性加载完成。在浏览器中执行时，浏览器 DOM 生成所请求的页面。 在 React 中，假设我们有这样的应用程序： 1234567891011121314151617181920212223242526// index.jsexport default () =&gt; ( &lt;Switch&gt; &lt;Route path="/about" component=&#123;About&#125; /&gt; &lt;Route path="/faq" component=&#123;FAQ&#125; /&gt; &lt;Route path="/careers" component=&#123;Careers&#125; /&gt; &lt;/Switch&gt;);// about.jsclass About extends Component &#123; render() &#123; return &lt;div&gt;About page&lt;/div&gt;; &#125;&#125;// faq.jsclass FAQ extends Component &#123; render() &#123; return &lt;div&gt;FAQ page&lt;/div&gt;; &#125;&#125;// careers.jsclass Careers extends Component &#123; render() &#123; return &lt;div&gt;Careers page&lt;/div&gt;; &#125;&#125; 在打包时，webpack 将所有的 js 文件打包成一个index.js 1234react-app/ dist/ - index.html - index.js 所有的文件包括 index.js, about.js, faq.js, careers.js 都捆绑在一个文件中。现在，当我们加载 index.html 文件时，它会沿着负载很重的 index.js 被加载。现在，解析 index.js 和渲染中的所有代码所花费的时间 ⏰ 将是漫长的等待。如果每个文件执行所花费的时间如下： index.js 2ms about.js 10ms faq.js 5ms careers.js 9ms 打包后: index.js 26ms 所以我们会等待26ms!!但是如果我们可以将 React 中的文件分开并按需加载它们，我们将在2ms内看到程序加载并相应。 因此，我们可以将包拆分成多个小块并在运行时动态加载，而非一次性下载整个代码。 已经有很多技术用于支持将 React apps 做代码拆分了。我们在下一节中有更多的讲解。 ⏬Dynamic Import 为了将我们的 JS 应用做代码分割，将引入 import()函数，目前它仍是一个提案，尚未成为 JavaScript 标准的一部分。 此功能可以将我们的应用程序拆分成为块并按需加载它们。 The import()接受一个字符串作为参数。字符串是将要加载的 js 文件的路径。 1import('./js_file_to_load.js'); 当 webpack 遇到这种情况时，它就会将文件分别捆绑在不同路径中。 💤React.lazy() React.lazy 是 Reactv16.6 发布时添加到 React 的新特性，它为我们的 React 组件提供了一种简单直接的方法来完成延迟加载和代码分割。 React.lazy 函数允许你将动态导入的组件按常规呈现。 — React blog React.lazy 可以轻松创建和渲染组件并动态的导入它们。React.lazy 将函数作为参数： 1234React.lazy(() =&gt; &#123;&#125;);// orfunction cb() &#123;&#125;React.lazy(cb); 这个回调函数必须使用动态import()语法来加载组件的文件： 12345678910111213141516171819202122232425262728// MyComponent.jsclass MyComponent extends Component &#123; render() &#123; return &lt;div&gt;MyComponent&lt;/div&gt;; &#125;&#125;const MyComponent = React.lazy(() =&gt; &#123; import('./MyComponent.js');&#125;);function AppComponent() &#123; return ( &lt;div&gt; &lt;MyComponent /&gt; &lt;/div&gt; );&#125;// orfunction cb() &#123; return import('./MyComponent.js');&#125;const MyComponent = React.lazy(cb);function AppComponent() &#123; return ( &lt;div&gt; &lt;MyComponent /&gt; &lt;/div&gt; );&#125; React.lazy 的回调函数会通过import()的调用返回一个 Promise 对象。如果模块加载成功则 Promise 对象 resolve，如果由于网络故障，路径解析错误，找不到文件等原因加载模块时出错，则 Promise 对象 reject。 当 webpack 遍历我们的代码进行编译打包的时候，它会在遇到React.lazy()和import()时，创建一个单独的捆绑包。我们的应用程序将如下显示： 12345678910react-app dist/ - index.html - main.b1234.js (contains Appcomponent and bootstrap code) - mycomponent.bc4567.js (contains MyComponent)/** index.html **/&lt;head&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;main.b1234.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 现在，我们的应用程序分为多个捆绑包。当 AppComponent 被渲染的时候，mycomponent.bc4567.js 文件将被加载并在 DOM 上的显示包含 MyComponent。 译者注：目前 React.lazy 还不支持服务端使用，目前官方推荐使用Loadable Components，它有很棒的服务端渲染指南。或者你也可以尝试使用react-loadable，这是一个小型库，用于加载具有动态导入组件的高阶组件，使用它你可以完成错误超时状态配置、避免加载闪烁、加载多个资源、预加载、服务端渲染等功能。 🚦React Suspense 现在，当文件 mycomponent.bc4567.js 被加载时会发生什么，从加载到 MyComponent 被渲染必定会有一个时间延迟。用户会看到什么呢？ 显然，你的应用程序似乎会冻结一段时间。这将是个糟糕的用户体验。我们需要让用户指导正在发生或加载的事情。为了做到这一点，添加了与 React.lazy 相关联的新特性，他就是Suspense组件。 Suspense 组件用于包装延迟组件，以在加载惰性组件时显示一些备用信息。 12345678910const Lazycomponent = React.lazy(() =&gt; import('./lazy.component.js'));function AppComponent() &#123; return ( &lt;div&gt; &lt;Suspense fallback=&#123;&lt;div&gt;loading ...&lt;/div&gt;&#125;&gt; &lt;LazyComponent /&gt; &lt;/Suspense&gt; &lt;/div&gt; );&#125; 正在延迟加载的组件将插入到 Suspense 组件的标记内。向用户展示的内容告诉他们正在进行的内容放在 Suspense 组件标记的 fallback prop 中。 组件也可以用于 fallback prop： 12345678910111213// ...function LoadingIndicator() &#123; return &lt;div&gt;loading ...&lt;/div&gt;;&#125;function AppComponent() &#123; return ( &lt;div&gt; &lt;Suspense fallback=&#123;&lt;LoadingIndicator /&gt;&#125;&gt; &lt;LazyComponent /&gt; &lt;/Suspense&gt; &lt;/div&gt; );&#125; 可以再 Suspense 标记中放置多个惰性组件。 123456789101112131415const Lazycomponent1 = React.lazy(() =&gt; import('./lazy.component1.js'));const Lazycomponent2 = React.lazy(() =&gt; import('./lazy.component2.js'));const Lazycomponent3 = React.lazy(() =&gt; import('./lazy.component3.js'));const Lazycomponent4 = React.lazy(() =&gt; import('./lazy.component4.js'));function AppComponent() &#123; return; &lt;div&gt; &lt;Suspense fallback=&#123;&lt;div&gt;loading ...&lt;/div&gt;&#125;&gt; &lt;LazyComponent1 /&gt; &lt;LazyComponent2 /&gt; &lt;LazyComponent3 /&gt; &lt;LazyComponent4 /&gt; &lt;/Suspense&gt; &lt;/div&gt;;&#125; 👮 捕获加载错误 在我们使用 React.lazy 时，我们提到 import()函数会返回一个 Promise 对象，可能会由于某些原因在 reject 中返回加载错误： 网络故障 文件未找到 文件路径错误 现在，我们不希望我们的应用程序因为这些悲惨地发生错误。我们希望荣耀的有尊严地错误。为了在失败时展现出良好的用户体验，我们将在惰性组件上放置一个错误边界。 123456789101112131415161718const Lazycomponent1 = React.lazy(()=&gt;import('./lazy.component1.js'))const Lazycomponent2 = React.lazy(()=&gt;import('./lazy.component2.js'))const Lazycomponent3 = React.lazy(()=&gt;import('./lazy.component3.js'))const Lazycomponent4 = React.lazy(()=&gt;import('./lazy.component4.js'))import ErrorBoundary from './error.boundary.js'function AppComponent() &#123; return &lt;div&gt; &lt;ErrorBoundary&gt; &lt;Suspense fallback=&#123;&lt;div&gt;loading ...&lt;/div&gt;&#125;&gt; &lt;LazyComponent1 /&gt; &lt;LazyComponent2 /&gt; &lt;LazyComponent3 /&gt; &lt;LazyComponent4 /&gt; &lt;/Suspense&gt; &lt;ErrorBoundary/&gt; &lt;/div&gt;&#125; ✂ 基于路由（route-based）的代码拆分 如何拆分代码是个棘手的问题。有两种最常用的方法是基于路由（route-based）拆分和基于组件（component-based）拆分。 基于路由的代码拆分将应用程序分解为每个路由对应的块。 基于路由的代码拆分是将代码拆分为与应用程序路由相关的包。在 SPA（single page web application，单页面应用）中，所有的 route 或 path 都是在 DOM 上完成的。当你点击超链接时，DOM 捕获事件并通过 SPA 框架运行它，在 DOM 中将销毁当前视图当组件附加请求路径创建并呈现的时候。 所有的这些组件都捆绑在一个文件中被传递。现在，通过基于路由的分块，我们可以将代码分成块。每个块只与特定路由有关。 123456789// index,js// ...const App = () =&gt; ( &lt;Switch&gt; &lt;Route path="/about" component=&#123;About&#125; /&gt; &lt;Route path="/faq" component=&#123;FAQ&#125; /&gt; &lt;Route path="/careers" component=&#123;Careers&#125; /&gt; &lt;/Switch&gt;); 当我们使用基于路由的方法拆分次应用程序时，我们将看到： 1234567891011react-app/ - index.html - index.bacd0123.js (contains App) - about.1234.js (contains About component) - faq.5678.js (contains FAQ component) - careers.9012.js (contains Careers component)/** index.html **/&lt;head&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;index.bacd0123.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 当我们加载我们的 app 路径/时，应用仅呈现该页面。现在，如果我们导航到/faq，那么 faq.5678.js 文件将通过网络获取并加载，包括组件 FAQ 将被渲染。 因此，我们将看到的代码是根据我们定义的路由进行拆分的。这并没有 100%优化我们的应用程序，有一些缺点，但至少我们从我们的应用程序中减少了相当大的延迟时间。这个与代码分割相关的另一种优化技术被称为 prefetching，但这将在另一篇文章中。 🔪 基于组件（Component-based）的代码拆分 在 Web 应用程序中，有如下许多小部件： 模型（modals） tabs 折叠面板（accordion） 进度条（progressbars） 侧边菜单（sidenav） footer header 面板（panel） 等等 这些小部件或组件为我们的用户提供了丰富的体验。 123456789101112function ModalComponent() &#123; return &lt;modal&gt;Modal shows!!!&lt;/modal&gt;;&#125;function Mycomponent() &#123; this.display = false; return; &lt;div&gt; &lt;ModalComponent display=&#123;this.dispaly&#125; /&gt; &lt;button onclick=&#123;(this.display = true)&#125;&gt;Open Modal&lt;/button&gt; &lt;button onclick=&#123;(this.display = false)&#125;&gt;Close Modal&lt;/button&gt; &lt;/div&gt;;&#125; 1234react-app/ dist/ - index.html - index.js 尽管他们提供了很多好东西，但他们也会导致我们的应用程序性能不佳。大多数组件隐藏，指导用户完成相关操作时才会显现。在用户滚动到底部或按侧边按钮之前，你不会看到 footer 和 sidenev。大多数情况下，用户甚至可能不会与其中任意一个进行交互。 所有这些都加载到我们的应用程序中，并在加载时构成时间延迟。当用户试图与他们交互时，加载并展现他们不会更好么？ 在这种情况下，基于组件的拆分有很大的帮助。所有的小部件或组件都将单独打包。每个捆绑包上一个小部件，Web 开发人员需要采用捆绑技术，但更重要的是按需加载这些部件。 123456789101112131415161718192021222324252627282930313233343536// modalcomponent.jsfunction ModalComponent() &#123; return &lt;modal&gt;Modal shows!!!&lt;/modal&gt;&#125;// mycomponent.jsconst ModalComponent = React.lazy(import('./modalcomponent.js'))function MyComponent() &#123; this.display = false; return &lt;div&gt; &lt;Suspense fallback=&#123;&lt;div&gt;loading ...&lt;/div&gt;&#125;&gt; &lt;ModalComponent display=&#123;this.display&#125; /&gt; &lt;/Suspense&gt; &lt;button onclick=&#123;this.display = true&#125;&gt;Open Modal&lt;/button&gt; &lt;button onclick=&#123;this.display = false&#125;&gt;Close Modal&lt;/button&gt; &lt;/div&gt;&#125;// index.jsconst MyComponent = React.lazy(()=&gt;import('./mycomponent.js'))import ErrorBoundary from './error.boundary.js'function AppComponent() &#123; return &lt;div&gt; &lt;ErrorBoundary&gt; &lt;Suspense fallback=&#123;&lt;div&gt;loading ...&lt;/div&gt;&#125;&gt; &lt;MyComponent /&gt; &lt;/Suspense&gt; &lt;ErrorBoundary/&gt; &lt;/div&gt;&#125;react-app/ dist/ - index.html - index.js - mycomponent.js - modalcomponent.js (contains the ModalComponent) 我们看到最初没有加载 ModalComponent，他在用户单击Open Modal按钮时，才会触发加载。 🔚 结论 在这篇文章中，我们看到了如何通过代码分割和延迟加载来改进 🚀React 应用程序的性能。首先我们介绍了动态 import()函数；然后，我们看到了还可以使用不同的技术方案，如 React 的新特性 💤React.lazy()和 🚦Suspense。 通过我们在这篇文章中学到的这些不同的优化技巧，我们可以生成高性能高质量的 React 应用。 如果你对此有任何问题，或者我有任何遗漏，请随时在下面发表评论或向我询问任何问题！👏 你也可以在Twitter, Facebook和这里找到我。 蟹蟹 !!!💯 💞Credits ✅Reactjs Blog 原文链接： Improve React Performance using Lazy Loading💤 and Suspense]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMAScript</tag>
        <tag>Web开发</tag>
        <tag>框架</tag>
        <tag>性能</tag>
        <tag>译文</tag>
        <tag>React</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[覆盖模式——提高React组件的复用率]]></title>
    <url>%2Farchives%2Ffront-end%2Fframe%2FReact%2FComponent%2F1546591536.html</url>
    <content type="text"><![CDATA[如果你在过去几年中一直在关注 React 生态系统，那么在众多用于开发人员在构建应用程序时可以使用的开源可重用组件库中，你至少曾尝试或听说过一个。这些库使我们不必再为每个应用程序反复构建相同的模态，菜单和表单控件。 那些曾经使用过其中一个库的人可能也遇到过一个组件不太适合你需要的场景，也许是组件的设计和你需要的不要一样，并且那些组件没有暴露出可以配置样式的 API；又或许是你只是想要一个样式自定义的复选框。 这在我们优步是一个很常见的情绪了，由于团队经常被迫开始构建一个新的组件，这导致了很多无谓的浪费。因此，当我们最近着手改造我们心爱（但老旧）的组件库的时候，我们调查了数十位工程师，一遍更好地了解他们在复用现有的组件时遇到的障碍。有几点很明确： Styles: 开发者需要能够配置组件及其内部组件的样式。这对于 global CSS 或许很容易，但是在 CSS-in-JS 的世界中，每个元素都可以有任意类封装在组件之中，想要实现就变得十分的困难了。 Props: 有时候你只是需要改变传递给内部组件的 props。例如给元素添加一个aria-label属性，或者是在集成测试中将className传递给指定的目标。 Render: 在很多情况下，人们只是希望能够完全覆盖某些内部的渲染或行为——例如，想添加到日期选择器添加一个快捷选择的选项（如：“过去 30 天”）。 我们当然不是第一个试图去解决这些问题的人。在 React 社区中推广的render props模式是一种允许更多方法控制一个组件渲染方式的策略。Paypal 的downshift 也是一个很好的例子，这使你可以明确如果使用 render props 可以达成的效果。 但是 render props 对于许多情况来说都是一个很好的工具，如果你只是想覆盖一个样式或者改变一些内部元素的 props，这样做可能就有点沉重了。类似的，组件作者有时候会提供像是getFooStyle或getFooProps这样的 props 来定制一些内部元素，但是这些很少以一致的方式提供给所有的内部组件。 我们希望在我们的组件中提供一个统一的 API，它提供了渲染所有的灵活方式，但同时有可以有捷径，适用于只需要覆盖一些内部样式或 props 非常频繁的场景。 我们提出的解决方案称之为“Overrides”模式（覆盖模式）。它仍在不断发展，但到目前为止，我们对开发人员使用它的方法感到印象深刻。我们希望与更广泛的社区分享，希望它能激发其他组件库作者的兴趣，或者至少提高对组件复用性当前缺陷的认识。下面将展示它是如何实现的。 覆盖公共的 API 下面的代码片段演示了覆盖模式在可复用 Autocomplete 组件的具体实现： 123456789101112131415161718192021222324252627// App.jsrender() &#123; &lt;Autocomplete options=&#123;this.props.products&#125; overrides=&#123;&#123; Root: &#123; props: &#123;'aria-label': 'Select an option'&#125;, style: (&#123;$isOpen&#125;) =&gt; (&#123;borderColor: $isOpen ? 'blue' : 'grey'&#125;), &#125;, Option: &#123; component: CustomOption &#125; &#125;&#125; /&gt;&#125;// CustomOption.jsexport default function CustomOption(&#123;onClick, $option&#125;) &#123; return ( &lt;div onClick=&#123;onClick&#125;&gt; &lt;h4&gt;&#123;$option.name&#125;&lt;/h4&gt; &lt;small&gt;&#123;$option.price&#125;&lt;/small&gt; &lt;/div&gt; );&#125;// https://gist.github.com/schnerd/045ee729696f0352bb106b186eb50855#file-overrides-example-public-js 这里有很多内容，让我们来看看一些关键的变化： 每一个内部元素都有一个开发者可以定位的标识符。这里我们使用的是Root和Option。你几乎可以将这些视为类名（但没有 CSS 级联和全局命名空间的缺点） 对于每个内部元素，你都可以覆盖props，style，和component. 覆盖 props 非常直接，你指定的对象将使用默认道具传递，并优先于它们。在这种情况下，你可以看到我们正在使用它在 Root 元素上来添加aria-label。 当覆盖style时，你可以传递一个样式对象或者接受与组件当前内部状态相关的一些道具的函数，允许你更具组件状态动态地更改样式，如isError或isSelected。函数返回的样式对象与默认元素样式深度合并。 当覆盖component时，可以传入无状态功能组件或 React 组件类，你可以在其中以供自己的渲染逻辑，也可以选择添加其他处理程序或行为。这实际上是依赖注入，并解锁了更多可能性。 通过一个统一的overrides支柱提供所有这些功能，为开发人员提供了一个一致的方法定制所需内容。 覆盖组件行为 为了让你了解我们团队如何使用此功能，以下是优步货运团队的一个示例： 他们想要使用同一个 API、键盘控制和事件为一个 radio 组来创建表单元素，但是有不同的视觉外观。他们能够在我们现有的RadioGroup组件智商添加一系列样式覆盖，而不必浪费地构建，测试和维护他们自己的自定义实现。 我们在对此模式进行原型设计时使用的另一个示例是向多选组件中的标记添加编辑行为。在这种情况下，我们创建了一个组件覆盖Tag，为其渲染了现有的内容，同时注入了一个编辑标签。 这说明了与 render props 相比允许注入完整组件的一个好处——你可以创建新的状态，生命周期方法，如果你需要的话甚至可以使用 React Hocks。我们的EditableTag组件在单击时能够显示模态，然后触发必要的 redux 操作以更新标记的名称。 覆盖内部实施（组件） 以下是我们 Autocomplete 组件内部可以实现的覆盖方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// Autocomplete.jsimport React from 'react';import * as defaultComponents from './styled-elements';class Autocomplete extends React.Component &#123; // Setup &amp; handlers omitted to keep this example short getSharedStyleProps() &#123; const &#123;isOpen, isError&#125; = this.state; return &#123; $isOpen: isOpen $isError: isError &#125;; &#125; render() &#123; const &#123;isOpen, query, value&#125; = this.state; const &#123;options, overrides&#125; = this.props; const &#123; Root: &#123;component: Root, props: rootProps&#125;, Input: &#123;component: Input, props: inputProps&#125;, List: &#123;component: List, props: listProps&#125;, Option: &#123;component: Option, props: optionProps&#125;, &#125; = getComponents(defaultComponents, overrides); const sharedProps = this.getSharedStyleProps(); return ( &lt;Root &#123;...sharedProps&#125; &#123;...rootProps&#125;&gt; &lt;Input type="text" value=&#123;query&#125; onChange=&#123;this.onInputChange&#125; &#123;...sharedProps&#125; &#123;...inputProps&#125; /&gt; &#123;isOpen &amp;&amp; ( &lt;List &#123;...sharedProps&#125; &#123;...listProps&#125;&gt; &#123;options.map(option =&gt; &#123; &lt;Option onClick=&#123;this.onOptionClick.bind(this, option)&#125; $option=&#123;option&#125; &#123;...sharedProps&#125; &#123;...optionProps&#125; &gt; &#123;option.label&#125; &lt;/Option&gt; &#125;)&#125; &lt;/List&gt; )&#125; &lt;/Root&gt; ); &#125;&#125;// https://gist.github.com/schnerd/30c1415b7621d0e71352aa0c0184f175#file-overrides-example-internal-js 请注意，render 方法不包含像&lt;div&gt;这样的原生 DOM。我们从相邻的文件中导入默认的子组件。在这个文件中我们使用 CSS-in-JS 库来创建封装所有默认样式的组件。如果组件传递了overrides，则它优先于这些默认值。 getComponents只是一个很简单的辅助函数，我们使用它来解压需要覆盖的参数并将它们与组件的默认样式合并到一处。很多方法可以实现这，下面是个简短的示例： 123456789101112function getComponents(defaultComponents, overrides) &#123; return Object.keys(defaultComponents).reduce((acc, name) =&gt; &#123; const override = overrides[name] || &#123;&#125;; acc[name] = &#123; component: override.component || defaultComponents[name], props: &#123; $style: override.style, ...override.props &#125;, &#125;; return acc; &#125;, &#123;&#125;);&#125;// https://gist.github.com/schnerd/c6753b941954f96ec16fea2ce47e74d8#file-overrides-example-getcomponents-js 这个函数指定了 style 覆盖到为名为$style的 prop，并将其与其他的覆盖 prop 合并到一起——这主要是因为我们使用 CSS-in-JS 实现了查找$style并将其与默认样式深度合并。 每个子组件也接受sharedProps，它可以用于动态更改样式或渲染——例如，在出现错误时将 border-color 设置为 red。我们将这些 props 添加$前缀作为一个命名规则的约定，以表明这些是特殊的 props，不应该传递给底层的 DOM 元素。 权衡 &amp; 陷阱 与大多数设计模式一样，在使用覆盖模式的时候也需要全更一些因素。 刚性 因为每个内部元素都有一个标识符并作为覆盖的目标公开，所以更改 DOM 结构可能会导致超出预期的变化出现频次高于正常情况。对于 CSS 的变化来说也会有同样的问题——改变元素样式从display: flex到display: block理论上同样是个重大的改变，如果使用者觉得这是一个 flexbox 的内部并这样覆盖其中一个子元素的样式。通常都整齐封装的组件实际上可能会使下游受到影响从而出现问题。 所以的这些都意味着你可能需要更加小心地改变组件的 DOM 结构或者样式，并且不要害怕当一个主要版本的修改受到质疑的时候。 文档 现在你的内部元素是公共 API 的一部分，你可能会希望编写一个文档去描述每个元素以及它可以传入的 porps。包括使用一些简单的图表来描述它的 DOM 结构，以及它们的标识。 使用 TypeScripts 或 Flow 这类可以静态类型检查的方法在这里会是一个很棒的方案，因为它将使开发人员清楚地知道每个组件可以接受哪些 props，以及你覆盖的方式是否兼容。 组成 想象一下，你正在使用Button组件来构建一个可复用的Pagination组件来完成分页功能，我们如何将Pagination组件内的Button组件覆盖方法暴露出来呢？如果有多个按钮（例如：首页、上一页、下一页、尾页等），使用者可能想要以不同的方式去设置该怎么办？我们对于如何处理这一类问题有些想法，但是这并不能解决根本，在最终方案出现之前还需要反复地去实验。 复杂性 支持组件的复用会提升其复杂性，并且破事你更加批判性的考虑使用者如何覆盖你的内部组件。如果你只是构建一个将在自己的应用程序中重复使用几次的组件，那么这种复杂性的增加可能并不值得。但是如果你正在构建一个可供数百名工程师使用的可复用的组件库，那么为了这些使用者的便利而牺牲简洁的写法就非常有意义了。对于我们来说这是一个简单的决定，因为那工程师使用组件时那些有趣的用法一直令我们印象深刻。 展望 现在来说，覆盖模式只是一种模式，并没有刻意安装的库或者包，但是如果你想看看我们在自己的组件库中如何使用这个模式，你可以在github上浏览我们的项目。 希望你发现这个模式刻意很有用，或者至少有一些关于如何提高你的 React 组件复用率的新想法！ — 有疑问或想法吗？你可以发表评论或者在推特上找到我哦：@dschnr 原文链接: https://medium.com/@dschnr/better-reusable-react-components-with-the-overrides-pattern-9eca2339f646]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
        <category>React</category>
        <category>Component</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>ECMAScript</tag>
        <tag>框架</tag>
        <tag>译文</tag>
        <tag>React</tag>
        <tag>组件样式</tag>
        <tag>CSS In JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React PureComponent 使用指南]]></title>
    <url>%2Farchives%2Ffront-end%2Fframe%2FReact%2FComponent%2F1530426597.html</url>
    <content type="text"><![CDATA[为什么使用？ React15.3 中新加了一个 PureComponent 类，顾名思义， pure 是纯的意思， PureComponent 也就是纯组件，取代其前身 PureRenderMixin , PureComponent 是优化 React 应用程序最重要的方法之一，易于实施，只要把继承类从 Component 换成 PureComponent 即可，可以减少不必要的 render 操作的次数，从而提高性能，而且可以少写 shouldComponentUpdate 函数，节省了点代码。 原理 当组件更新时，如果组件的 props 和 state 都没发生改变， render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。具体就是 React 自动帮我们做了一层浅比较： 1234if (this._compositeType === CompositeTypes.PureClass) &#123; shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);&#125; 而 shallowEqual 又做了什么呢？会比较 Object.keys(state | props) 的长度是否一致，每一个 key 是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。 使用指南 易变数据不能使用一个引用 案例： 12345678910111213141516171819202122class App extends PureComponent &#123; state = &#123; items: [1, 2, 3], &#125;; handleClick = () =&gt; &#123; const &#123; items &#125; = this.state; items.pop(); this.setState(&#123; items &#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;ul&gt; &#123;this.state.items.map((i) =&gt; ( &lt;li key=&#123;i&#125;&gt;&#123;i&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;delete&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 会发现，无论怎么点 delete 按钮， li 都不会变少，因为 items 用的是一个引用， shallowEqual 的结果为 true 。改正： 12345handleClick = () =&gt; &#123; const &#123; items &#125; = this.state; items.pop(); this.setState(&#123; items: [].concat(items) &#125;);&#125;; 这样每次改变都会产生一个新的数组，也就可以 render 了。这里有一个矛盾的地方，如果没有 items.pop(); 操作，每次 items 数据并没有变，但还是 render 了，这不就很操蛋么？呵呵，数据都不变，你 setState 干嘛？ 不变数据使用一个引用 子组件数据 上面易变数据不能使用一个引用的案例中有一个点击删除操作，如果我们删除的代码这么写： 12345handleClick = () =&gt; &#123; const &#123; items &#125; = this.state; items.splice(items.length - 1, 1); this.setState(&#123; items &#125;);&#125;; items 的引用也是改变的，但如果 items 里面是引用类型数据： 1items: [&#123; a: 1 &#125;, &#123; a: 2 &#125;, &#123; a: 3 &#125;]; 这个时候 1state.items[0] === nextState.items[0]; // false 子组件里还是re-render了。这样就需要我们保证不变的子组件数据的引用不能改变。这个时候可以使用 immutable-js 函数库。 函数属性 我们在给组件传一个函数的时候，有时候总喜欢: 123456789// 1&lt;MyInput onChange=&#123;e =&gt; this.props.update(e.target.value)&#125; /&gt;// 2update(e) &#123; this.props.update(e.target.value)&#125;render() &#123; return &lt;MyInput onChange=&#123;this.update.bind(this)&#125; /&gt;&#125; 由于每次 render 操作 MyInput 组件的 onChange 属性都会返回一个新的函数，由于引用不一样，所以父组件的 render 也会导致 MyInput 组件的 render ，即使没有任何改动，所以需要尽量避免这样的写法，最好这样写： 1234567// 1,2update = (e) =&gt; &#123; this.props.update(e.target.value)&#125;render() &#123; return &lt;MyInput onChange=&#123;this.update&#125; /&gt;&#125; 空对象、空数组或固定对象 有时候后台返回的数据中，数组长度为 0 或者对象没有属性会直接给一个 null ，这时候我们需要做一些容错： 123456789101112131415161718192021222324252627class App extends PureComponent &#123; state = &#123; items: [&#123; name: 'test1' &#125;, null, &#123; name: 'test3' &#125;], &#125;; store = (id, value) =&gt; &#123; const &#123; items &#125; = this.state; items[id] = assign(&#123;&#125;, items[id], &#123; name: value &#125;); this.setState(&#123; items: [].concat(items) &#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;ul&gt; &#123;this.state.items.map((i, k) =&gt; ( &lt;Item style=&#123;&#123; color: 'red' &#125;&#125; store=&#123;this.store&#125; key=&#123;k&#125; id=&#123;k&#125; data=&#123;i || &#123;&#125;&#125; /&gt; ))&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125; 当某一个子组件调用 store 函数改变了自己的那条属性，触发 render 操作，如果数据是 null 的话 data 属性每次都是一个 {}，{} ==== {} 是 false 的，这样无端的让这几个子组件重新 render 了。{ color: 'red' }也是一样。 最好设置一个 defaultValue 为 {},如下： 123static defaultValue = &#123;&#125;const style = &#123; color: 'red' &#125;;&lt;Item style=&#123;style&#125; store=&#123;this.store&#125; key=&#123;k&#125; id=&#123;k&#125; data=&#123;i || defaultValue&#125; /&gt; 复杂状态与简单状态不要共用一个组件 这点可能和 PureComponent 没多少关系，但做的不好可能会浪费很多性能，比如一个页面上面一部分是一个复杂的列表，下面是一个输入框，抽象代码： 1234567891011change = (e) =&gt; &#123; this.setState(&#123; value: e.target.value &#125;);&#125;render() &#123; return (&lt;div&gt; &lt;ul&gt; &#123;this.state.items.map((i, k) =&gt; &lt;li key=&#123;k&#125;&gt; &#123;...&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; &lt;input value=&#123;this.state.value&#125; onChange=&#123;this.change&#125; /&gt; &lt;/div&gt;)&#125; 表单和列表其实是没有什么关联的，表单的值也可能经常变动，但它的会给列表也带来必然的 diff 操作，这是没必要的，最好是给列表抽出成一个单独的 PureComponent 组件，这样 state.items 不变的话，列表就不会重新 render 了。 与 shouldComponentUpdate 共存 如果 PureComponent 里有 shouldComponentUpdate 函数的话，直接使用 shouldComponentUpdate 的结果作为是否更新的依据，没有 shouldComponentUpdate 函数的话，才会去判断是不是 PureComponent ，是的话再去做 shallowEqual 浅比较。 123456789101112// 这个变量用来控制组件是否需要更新var shouldUpdate = true;// inst 是组件实例if (inst.shouldComponentUpdate) &#123; shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);&#125; else &#123; if (this._compositeType === CompositeType.PureClass) &#123; shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState); &#125;&#125; 老版本兼容写法 12345import React &#123; PureComponent, Component &#125; from 'react';class Foo extends (PureComponent || Component) &#123; //...&#125; 这样在老版本的 React 里也不会挂掉。 总结 PureComponent 真正起作用的，只是在一些纯展示组件上，复杂组件用了也没关系，反正 shallowEqual 那一关就过不了，不过记得 props 和 state 不能使用同一个引用哦。 原文链接：wulv.site]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
        <category>React</category>
        <category>Component</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMAScript</tag>
        <tag>框架</tag>
        <tag>React</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fetch使用整理]]></title>
    <url>%2Farchives%2Ffront-end%2Fnetwork-request%2Ffetch%2F1528704177.html</url>
    <content type="text"><![CDATA[浏览器支持情况 fetch是相对较新的技术，当然就会存在浏览器兼容性的问题，当前各个浏览器低版本的情况下都是不被支持的，因此为了在所有主流浏览器中使用fetch 需要考虑 fetch 的 polyfill 了 require('es6-promise').polyfill(); require('isomorphic-fetch'); 引入这两个文件，就可以支持主流浏览器了 API fetch(url,{ // url: 请求地址 method: &quot;GET&quot;, // 请求的方法POST/GET等 headers : { // 请求头（可以是Headers对象，也可是JSON对象） 'Content-Type': 'application/json', 'Accept': 'application/json' }, body: , // 请求发送的数据 blob、BufferSource、FormData、URLSearchParams（get或head方法中不能包含body） cache : 'default', // 是否缓存这个请求 credentials : 'same-origin', //要不要携带 cookie 默认不携带 omit、same-origin 或者 include mode : &quot;&quot;, /* mode,给请求定义一个模式确保请求有效 same-origin:只在请求同域中资源时成功，其他请求将被拒绝（同源策略） cors : 允许请求同域及返回CORS响应头的域中的资源，通常用作跨域请求来从第三方提供的API获取数据 cors-with-forced-preflight:在发出实际请求前执行preflight检查 no-cors : 目前不起作用（默认） */&lt;/span&gt; }).then(resp =&gt; { /* Response 实现了 Body, 可以使用 Body 的 属性和方法: resp.type // 包含Response的类型 (例如, basic, cors). resp.url // 包含Response的URL. resp.status // 状态码 resp.ok // 表示 Response 的成功还是失败 resp.headers // 包含此Response所关联的 Headers 对象 可以使用 resp.clone() // 创建一个Response对象的克隆 resp.arrayBuffer() // 返回一个被解析为 ArrayBuffer 格式的promise对象 resp.blob() // 返回一个被解析为 Blob 格式的promise对象 resp.formData() // 返回一个被解析为 FormData 格式的promise对象 resp.json() // 返回一个被解析为 Json 格式的promise对象 resp.text() // 返回一个被解析为 Text 格式的promise对象 */&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(resp.status === &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; resp.json(); &lt;span class=&quot;hljs-comment&quot;&gt;// 注： 这里的 resp.json() 返回值不是 js对象，通过 then 后才会得到 js 对象&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; New &lt;span class=&quot;hljs-built_in&quot;&gt;Error&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;'false of json'&lt;/span&gt;); }).then(json =&gt; { console.log(json); }).catch(error =&gt; { consolr.log(error); }) 常用情况 请求 json fetch('http://xxx/xxx.json').then(res =&gt; { return res.json(); }).then(res =&gt; { console.log(res); }) 请求文本 fetch('/xxx/page').then(res =&gt; { return res.text(); }).then(res =&gt; { console.log(res); }) 发送普通 json 数据 fetch('/xxx', { method: 'post', body: JSON.stringify({ username: '', password: '' }) }); 发送form 表单数据 var form = document.querySelector('form'); fetch('/xxx', { method: 'post', body: new FormData(form) }); 获取图片 URL.createObjectURL() fetch('/xxx').then(res =&gt; { return res.blob(); }).then(res =&gt; { document.querySelector('img').src = URL.createObjectURL(imageBlob); }) 上传 var file = document.querySelector('.file') var data = new FormData() data.append('file', file.files[0]) fetch('/xxx', { method: 'POST', body: data }) 封装 require('es6-promise').polyfill(); require('isomorphic-fetch'); export default function request(method, url, body) { method = method.toUpperCase(); if (method === ‘GET’) { body = undefined; } else { body = body &amp;&amp; JSON.stringify(body); } &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; fetch(url, { method, headers: { &lt;span class=&quot;hljs-string&quot;&gt;'Content-Type'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'application/json'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'Accept'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'application/json'&lt;/span&gt; }, body }).then((res) =&amp;gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (res.status &amp;gt;= &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt; &amp;amp;&amp;amp; res.status &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;300&lt;/span&gt;) { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res; } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Promise.reject(&lt;span class=&quot;hljs-string&quot;&gt;'请求失败！'&lt;/span&gt;); } }) } export const get = path =&gt; request(‘GET’, path); export const post = (path, body) =&gt; request(‘POST’, path, body); export const put = (path, body) =&gt; request(‘PUT’, path, body); export const del = (path, body) =&gt; request(‘DELETE’, path, body); 参考 Fetch API 初探 Fetch API XHR or Fetch API ? 作者：mjzhang1993 来源：CSDN 原文：https://blog.csdn.net/mjzhang1993/article/details/72833095 版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
      <categories>
        <category>前端</category>
        <category>网络请求</category>
        <category>fetch</category>
      </categories>
      <tags>
        <tag>归纳</tag>
        <tag>JavaScript</tag>
        <tag>接口</tag>
        <tag>API</tag>
        <tag>转载</tag>
        <tag>ES7</tag>
        <tag>fetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于第三方API跨域那些事]]></title>
    <url>%2Farchives%2FNodejs%2F1521617316.html</url>
    <content type="text"><![CDATA[我们在项目开发中，使用第三方接口难免会遇到一些跨域问题，而跨域这个话题网上已经讨论了无数遍了。常用的有： jsonp cors 服务端反向代理（因为服务端不存在跨域问题） 现在推荐的方式是CORS 跨资源共享。在我看来，CORS 本质是一种白名单，其关字段为 Access-Control-Allow-Origin，通过标记请求发起站点是否可以访问目标站点的资源，达到跨域的目的。CORS 支持所有的 http 方法，可以说是跨域的本质解决方案。jsonp 本质是一个 hack，现在不推荐使用了。 那么我们在使用第三方 API 的时候，API 的提供者是怎样处理跨域问题呢？以cnode.js 开放平台为例，我们访问一个 APIAccess-Control-Allow-Origin:*，它就是允许所有站点可以跨域访问它的标志。但是有的接口，可能没有这个响应字段。我们在自己造玩具、开发调试的时候怎么处理呢？ 以vue-cli:2.8.2为例，我们可以在config/index.js中修改如下代代码： 1234567proxyTable: &#123; '/api': &#123; //将www.exaple.com印射为/apis target: 'http://127.0.0.1:5000', // 接口域名 changeOrigin: true, //是否跨域 secure: false &#125;&#125; 这段代码会为 webpack-dev-server 提供一个代理配置，它内部使用http-proxy-middleware，一个非常强大的 node 代理工具，这个是可以通过反向代理，实现开发中跨域访问接口的。 那么我们自己来模拟代理要如何来做呢？在学习的过程，我们可以用express作为服务器实现接口转发，这种技术或者叫中间层越来越流行。一般是一传统的Java，PHP，Python, Golang等后台语言作为服务器开发接口，前端通过 node 中间层来转发接口，返回前端想要的数据格式，极大的提高了接口开发的效率和需求的多样性。现在我们来实现一个简单的express转发接口，实现跨域和返回自己想要的数据。 我们以 https://www.v2ex.com/api 接口为例，这个接口的响应头没有Access-Control-Allow-Origin字段，所以正常使用 axios 调用此类接口，虽然可以访问到数据，但是 axios 本身的跨域错误机制，导致我们无法使用其返回的数据。express登场了，我们将使用它来实现接口转发实现跨域。首先我们准备一个路由文件config/proxy.js： 12345678module.exports = &#123; '/api/now': 'https://www.v2ex.com/api/topics/latest.json', '/api/hot': 'https://www.v2ex.com/api/topics/hot.json', '/api/node': 'https://www.v2ex.com/api/nodes/show.json', '/api/userinfo': 'https://www.v2ex.com/api/members/show.json', '/api/replies': 'https://www.v2ex.com/api/replies/show.json', '/api/topics': 'https://www.v2ex.com/api/topics/show.json',&#125;; 这里我重新定义了接口的名称，你可以把他任意定为你想要的名字。接下来准备一个server.js，也就是我们服务端的主文件： 123456789101112131415161718192021222324252627282930313233343536const express = require('express');const path = require('path');const axios = require('axios');const app = express();// 引入第三方路由const proxyConf = require('./config/proxy');const headerConf = &#123; referer: 'https://www.v2ex.com', host: 'www.v2ex.com',&#125;;let apiRoutes = express.Router();for (let k in proxyConf) &#123; app.get(k, function(req, res) &#123; axios .get(proxyConf[k], &#123; headers: headerConf, params: req.query, &#125;) .then((response) =&gt; &#123; res.setHeader('Access-Control-Allow-Origin', '*'); res.json(response.data); &#125;) .catch((e) =&gt; &#123; console.log(e); &#125;); &#125;);&#125;app.use('/', apiRoutes);app.use(express.static(path.join(__dirname, 'dist')));const port = process.env.PORT || 5000;app.listen(port);console.log('server started ' + port); 执行node server.js 这里关键代码为res.setHeader('Access-Control-Allow-Origin', '*')，我们主动给这个简单的 http 服务器的响应头设置了允许跨域访问，所以你可以通过 axios 调用http://127.0.0.1:5000/api/now等接口而不会出现跨域报错的问题。在 res.json(response.data)这个操作之前，我们可以根据请求消息req处理返回消息response.data，比如分页，达到我们想要返回的数据的目的。这样我们就模拟了一个反向代理服务器。^-^ 最后，欢迎在GitHub留言，一起学习 js，一起进步。 原文链接：zouhangwithsweet.github.io]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>接口</tag>
        <tag>API</tag>
        <tag>转载</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub 项目徽章的添加和设置]]></title>
    <url>%2Farchives%2Fmarkdown%2Fbadge%2F1514942003.html</url>
    <content type="text"><![CDATA[许多同学在 GitHub 上发布了自己的开源项目，有辛苦开发的实用工具、构思巧妙的开源库、别具一格的 App、精心整理的示例代码等等。 自己花了大把时间和精力构建的项目，当然是希望能够得到更多人的关注，被更多的人知晓或者使用。如何更好滴向他人展示自己的项目，介绍项目相关信息呢？用一些通用的小图标来描述项目相关信息不失为一种很棒的选择，几个好看的徽标能够为自己的项目说明增色不少！ 提示：因为文中某些示例需要 GitHub 的 Markdown 环境支持，所以如果遇到阅读问题，可以在 GitHub 查看，地址为 github.com/EyreFree/EF…。 徽标简介 GitHub 项目的 README.md 中可以添加徽章（Badge）对项目进行标记和说明，这些好看的小图标不仅简洁美观，而且还包含了清晰易读的信息。 徽标主要由图片和对应的链接（当然，你可以不填）组成，徽标图片的话一般由左半部分的名称和右半部分的值组成。 GitHub 徽标的官方网站是 shields.io/，我萌可以在官网预览绝大部分的徽标样式，然后选择自己喜欢的（当然首先需要适用于自己的目标项目）徽标，添加到自己的项目文档中去。 下面贴出几个例子以供参考： 徽标并不是添加的越多越好，合理地选择适合项目的徽标做具有针对性地添加才是理性的做法，像 EFQRCode 这样堆积徽标的无脑行为并不是十分可取，在这里提出这一点，希望大家不要盲目追求数量。 当然如果个人比较喜欢的话，请随意添加。 常用徽标添加 常用的徽标主要有持续集成状态、项目版本信息、代码测试覆盖率、项目支持平台、项目语言、代码分析等，下面我萌就来依次添加这些可爱的徽标！ 持续集成状态 持续集成的话推荐 Travis CI，针对开源项目免费，所以你的私有项目无法享受到免费的持续构建服务，不过我们的目的貌似就是给开源项目添加徽标。 同类型的产品还有 CircleCI，不过目前跑 OS X 项目需要额外付费，免费版提供一个 Linux 项目队列，作为非付费用户在这里不多做评价，大佬们可以自己试下。其他还有诸如 Jenkins 和 Codeship 等，大家可以在 shields.io/ 的 Build 这一栏自行翻阅。 接下来就是 Travis CI 的集成工作了，首先打开 travis-ci.org/ 注册一个 Travis-CI 账号，可以通过 GitHub 账户直接登陆。 然后参考 官方文档，根据你的项目语言或类型选择具体的配置方式，主要就是在项目中添加一个 .travis.yml 配置文件，告诉 Travis CI 怎样对你的项目进行编译或测试。这里有一个 Swift CocoaPods 库的集成示例，可以参考一下：www.jianshu.com/p/beaa9ec91…。 然后徽标图片地址是这个样子的： 1http://img.shields.io/travis/&#123;GitHub 用户名&#125;/&#123;项目名称&#125;.svg 将上面 URL 中的 {GitHub 用户名} 和 {项目名称} 替换为你的即可，再加上该项目在 Travis CI 上的地址，以 Alamofire 为例，最后集成完成的 Markdown 代码和效果大概是这个样子： 1[![](https://user-gold-cdn.xitu.io/2017/12/13/1604ec3c62a7de14)](https://travis-ci.org/Alamofire/Alamofire) 当然如果你的编译没跑过或者发生错误之类的，会出现其他的状态，比如酱紫的： 这里需要指出的是，开源项目的 Travis CI 也是公开的，包括日志和历史记录在内，都是针对所有人可见的，所以小伙伴们一定不要把密码、私钥等重要信息暴露了。 项目下载量 项目被下载的次数，这个的话各个平台的统计都是独立的，比如发布在 CocoaPods 的项目下载量徽标图片地址如下，以 AFNetworking 为例： 123总下载量：https://img.shields.io/cocoapods/dt/AFNetworking.svg月下载量：https://img.shields.io/cocoapods/dm/AFNetworking.svg周下载量：https://img.shields.io/cocoapods/dw/AFNetworking.svg 效果如下： 如果你的库已经发布到 CocoaPods 的话，我们只要把上面的 AFNetworking 改为自己的项目名称即可。更多其他发布方式如 apm、npm、Gem 等可查阅 shields.io/ 的 Downloads 一栏。 项目版本信息 这个的话，因为我的 iOS 库是发布在 CocoaPods 的，我用的是 CocoaPods 提供的，URL 如下： 1https://img.shields.io/cocoapods/v/&#123;项目名称&#125;.svg?style=flat 以 Alamofire 为例，Markdown 代码和效果如下： 1![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat) 如果你的库已经发布到 CocoaPods 的话，我们只要把上面的 Alamofire 改为自己的项目名称即可。更多其他发布方式如 apm、npm、Gem 等可查阅 shields.io/ 的 Version 一栏，这里提供一个可以查询已发布的各种包的版本号徽标地址的网站 badge.fury.io/，可以轻松获取对应包的徽标代码，如下图所示 如果你的发布工具不提供项目版本信息的徽标的话，可以用自定义徽标的方式实现，具体可参考下文自定义徽标一节，这里给出徽标代码： 1https://img.shields.io/badge/&#123;发布方式&#125;-&#123;版本号&#125;-519dd9.svg 将 {发布方式} 和 {版本号} 替换为你的项目目前的发布方式和版本号即可，例如通过 360 应用商店发布，发布版本号为 v1.2.3： 1![](https://img.shields.io/badge/360_store-v1.2.3-519dd9.svg) 代码测试覆盖率 代码测试覆盖率的话推荐 Codecov。同类产品有 Coveralls，不过网站风格略复古，文档也不详细，安装过程也复杂，需要配置一大堆奇怪的东西，遂不推荐。 同样的，Codecov 可以直接使用 GitHub 账号登陆，需要结合 Travis CI 使用，在 .travis.yml文件中添加一个回调触发 Codecov 的刷新，同时需要打开工程中的测试覆盖信息收集，XCode 中的设置如下 更多信息可参考 官方文档 和 示例。 然后，我们就可以在 Setting 中的 Badge 一栏找到添加图标的代码啦： 最终效果如下： 项目支持平台 这个的话，因为我的 iOS 库是发布在 CocoaPods 的，我用的是 CocoaPods 提供的，URL 如下： 1https://img.shields.io/cocoapods/p/&#123;项目名称&#125;.svg?style=flat 以 Alamofire 为例，Markdown 代码和效果如下： 1![](https://img.shields.io/cocoapods/p/Alamofire.svg?style=flat) 如果你的库已经发布到 CocoaPods 的话，我们只要把上面的 Alamofire 改为自己的项目名称即可。如果你的发布工具不提供项目支持平台的徽标的话，可以用自定义徽标的方式实现，具体可参考下文自定义徽标一节，这里给出徽标代码： 1https://img.shields.io/badge/platform-&#123;项目支持平台&#125;-lightgrey.svg 将 {项目支持平台} 替换为你的项目目前的版本号即可，例如 ios： 1![](https://img.shields.io/badge/platform-ios-lightgrey.svg) 项目语言 嗯，这个完全是用自定义徽标实现的，具体可参考下文自定义徽标一节，这里给出徽标代码： 1https://img.shields.io/badge/language-&#123;项目语言&#125;-&#123;背景色&#125;.svg 将 {项目语言} 和 {背景色} 替换为你的项目目前的语言和你想要的背景色即可，这里以 Swift 为例，我们用上 Swift 官方橘色： 1![](https://img.shields.io/badge/language-swift-orange.svg) 完美! 代码质量分析 Codebeat 可以计算全局项目评分、GPA、和不同命名空间的等级来帮助您量化技术债务和发现重构机会，你唯一需要做的就是连接你的 Github 库，获得反馈就好了。 嗯，上面是官方自述，大概意思就是每次 push 或者 merge 之后会对代码进行分，给出评分，然后告诉你哪些地方复杂度过高需要进行重构之类的。用 GitHub 登陆后绑定项目即可，无需对原有项目进行修改（其实是 codebeat 在你的项目设置里加了一个 Webhook，通知它重新计算评分）。 照着引导巴拉巴拉一顿操作之后就可以获取图标啦，在项目的 Setting 中可以获取徽标代码，自己复制出来就可以。 最终效果如下： 1[![codebeat badge](data:image/svg+xml;utf8,)](https://codebeat.co/projects/github-com-eyrefree-efqrcode-master) 更多信息可参考我的另一篇博文 利用 CodeBeat 为你在 GitHub 上的项目进行代码质量管理。 开源协议类型 这个的话，因为我的 iOS 库是发布在 CocoaPods 的，我用的是 CocoaPods 提供的，URL 如下： 1https://img.shields.io/cocoapods/l/&#123;项目名称&#125;.svg?style=flat 以 Alamofire 为例，Markdown 代码和效果如下： 1![](https://img.shields.io/cocoapods/l/Alamofire.svg?style=flat) 如果你的库已经发布到 CocoaPods 的话，我们只要把上面的 Alamofire 改为自己的项目名称即可。如果你的发布工具不提供开源协议类型的徽标的话，可以用自定义徽标的方式实现，具体可参考下文自定义徽标一节，这里给出徽标代码： 1https://img.shields.io/badge/license-&#123;协议名称&#125;-000000.svg 将 {协议名称} 替换为你的项目所使用的协议名称即可，例如 MIT： 1![](https://img.shields.io/badge/license-MIT-000000.svg) ![img](data:image/svg+xml;utf8,) 自定义徽标 标题／内容／颜色／链接 如果以上这些徽标没有满足你的需求，我们还可以定制自己的个性化徽标，shields.io 提供了添加自定义徽标的功能，通过修改如下 URL 即可获取自定义徽标图片： 1https://img.shields.io/badge/&#123;徽标标题&#125;-&#123;徽标内容&#125;-&#123;徽标颜色&#125;.svg {徽标标题}：徽标左半部分的文本（短线：–，下划线：_，空格： 或）； {徽标内容}：徽标右半部分的文本，同上； {徽标颜色}：徽标右半部分背景颜色，可以是 red、green、blue 等颜色英文单词，也可以直接写十六进制的颜色值，如 ff69b4，示例如下： 将其中的 {徽标标题}、{徽标内容}、{徽标颜色} 分别替换为需要的内容即可，例如我的微博徽标图片地址如下： 1https://img.shields.io/badge/weibo-@EyreFree-red.svg 再结合我的微博地址 weibo.com/eyrefree777 后完整徽标代码和效果如下（如果这段代码用在 GitHub 的话，点击该徽标会打开对应的 URL 地址，即直接跳到我的微博）： 1[![](https://img.shields.io/badge/weibo-@EyreFree-red.svg)](http://weibo.com/eyrefree777) ![img](data:image/svg+xml;utf8,) 同理我的推特徽标代码和效果如下： 1[![](https://img.shields.io/badge/twitter-@EyreFree777-blue.svg)](https://twitter.com/EyreFree777) ![img](data:image/svg+xml;utf8,) 附加参数 可以在徽标图片 URL 后面带上一些参数来控制徽标的样式，这一部分是可选的，不想折腾的话默认的样式就挺好了，可以不看这里的。 使用方法就是在徽标图片 URL 后面跟上 ?{参数名}={参数值} 多个参数联用的话就是 ?{参数名1}={参数值1}&amp;{参数名2}={参数值2}... style style 控制徽标的主体样式，有四种，不设置的话默认是 flat 的，示例代码和效果如下： plastic 塑料？大概是指立体效果 1![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=plastic) flat 正常的样子，扁平化 1![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat) flat-square 扁平化 + 去除圆角 1![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat-square) social 社交样式 1![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=social) label 该参数可以用来强制覆盖原有的徽标标题文字，效果如下，原有的 pod 字样已经被覆盖了： 1![](https://img.shields.io/cocoapods/v/Alamofire.svg?label=healthinesses) logo 该参数可以用来为徽标添加 logo，logo 图片会出现在左半部分的徽标标题左边，logo 图片高度必须 ≥ 14px，logo 图片需要先转为 base64 编码然后直接插入到 URL 中（可以用 b64.io/ 将图片转为 base64 编码的字符串），格式如下。 1?logo=&#123;base64 编码后的图片数据&#125; 示例代码和效果如下： 1![](https://img.shields.io/badge/gadget-Raspberry%20Pi-pink.svg?logo=data%3Aimage/png%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAACJ0lEQVR4AW2Qy0tUfxjGv3Pm3O%2BXGec3jnMZZ9Rxxp%2BWkYpJ2QkVIzDpkkoGBSOpBZmWgRIkWSs30SJchC26B9aijKLaFET9Be1q46ayRVDU5uk9Q8seeOG8X573eT/nZbwQqo5l5Rube52PQdH3BcaY4SbEiy2%2B/WFLv7ueblJv0luJmRHBHzqfwuyDRkzfKqB8pRZeQnwzuZynvgHTtwsYvZRBs2%2BVGSU5nfsjX2bocexqDsMLKXgZCQfmkzi6lK0EDJxOfNJdoYORQl5O3OeXY5%2BH59PI5XXUMh3RuIQR6v2J2Ld8h3488FXMBWb2TJkNPw9GUzirF3HX2oZFrQUD0Rqc84rfVcaPs0D/cTK/Q6y6N6eVsJX3MCglcUzJYVytw6CYxKRSj1Elu0bWCBNCXCnPGz96pTieOTvxyN6OIm/hid2Nx1SzWhGxsLwR4aQ9rFOMPl8lwwQlvXZ78NLZhRbBwZrTjReOjzuENKc1YUTOrLJ%2BKf7%2BsrEJhIL7dhfOaI34n7cxpRWwYnbghFqPMmENyelXzOLE0d1SNbrFGOKcgmDwnduH61Y7zJCAvVINDisZJMPqNEuHVeOQnPr11u3FESWLa2ZbBecp8VNaZXBBb15njHUxmxPC7YK3uGS0YkzNo1VwcZJWtwkeThHKMg33SfEVMqsskBeSjLqwMZYKa18ppXKRwESIv0u8NVPFyRb7hxK0ZYX%2BfIPO95D6KBXH/uoPnu/BfZ7Zxb0AAAAASUVORK5CYII) logoWidth 该参数可以设置在上一个参数 logo 中添加的图标的宽度，设为 0 的话即为忽略该参数，示例代码和效果如下： 1![](https://img.shields.io/badge/gadget-Raspberry%20Pi-pink.svg?logoWidth=100&amp;logo=data%3Aimage/png%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAACJ0lEQVR4AW2Qy0tUfxjGv3Pm3O%2BXGec3jnMZZ9Rxxp%2BWkYpJ2QkVIzDpkkoGBSOpBZmWgRIkWSs30SJchC26B9aijKLaFET9Be1q46ayRVDU5uk9Q8seeOG8X573eT/nZbwQqo5l5Rube52PQdH3BcaY4SbEiy2%2B/WFLv7ueblJv0luJmRHBHzqfwuyDRkzfKqB8pRZeQnwzuZynvgHTtwsYvZRBs2%2BVGSU5nfsjX2bocexqDsMLKXgZCQfmkzi6lK0EDJxOfNJdoYORQl5O3OeXY5%2BH59PI5XXUMh3RuIQR6v2J2Ld8h3488FXMBWb2TJkNPw9GUzirF3HX2oZFrQUD0Rqc84rfVcaPs0D/cTK/Q6y6N6eVsJX3MCglcUzJYVytw6CYxKRSj1Elu0bWCBNCXCnPGz96pTieOTvxyN6OIm/hid2Nx1SzWhGxsLwR4aQ9rFOMPl8lwwQlvXZ78NLZhRbBwZrTjReOjzuENKc1YUTOrLJ%2BKf7%2BsrEJhIL7dhfOaI34n7cxpRWwYnbghFqPMmENyelXzOLE0d1SNbrFGOKcgmDwnduH61Y7zJCAvVINDisZJMPqNEuHVeOQnPr11u3FESWLa2ZbBecp8VNaZXBBb15njHUxmxPC7YK3uGS0YkzNo1VwcZJWtwkeThHKMg33SfEVMqsskBeSjLqwMZYKa18ppXKRwESIv0u8NVPFyRb7hxK0ZYX%2BfIPO95D6KBXH/uoPnu/BfZ7Zxb0AAAAASUVORK5CYII) link 据说该参数是用来设置点击后跳转的 URL 的（嗯，俗称超链接），官方描述如下： Specify what clicking on the left/right of a badge should do (esp. for social badge style) 不过试了一下好像没啥效果（并且实在是没想明白怎么通过返回的图片控制不同点击区域的跳转），如果有大佬知道的求指点，感谢！ colorA 该参数用来控制徽标左半部分的背景色，只能用十六进制的颜色作为参数哦，不能直接写 red、green、blue 之类的，这里将左半部分的背景色改为 0xabcdef，代码和效果如下： 1![](https://img.shields.io/badge/twitter-@EyreFree777-blue.svg?colorA=abcdef) colorB 该参数用来控制徽标右半部分的背景色，同上，只能用十六进制的颜色作为参数哦，不能直接写 red、green、blue 之类的，这里将右半部分的背景色改为 0xabcdef，代码和效果如下： 1![](https://img.shields.io/badge/twitter-@EyreFree777-blue.svg?colorB=abcdef) maxAge 该参数用来设置 HTTP 缓存时间，以秒为单位，直接在 svg 地址后跟 ?maxAge={缓存秒数} 即可，好像没啥好预览的，不放效果图了。 备注 这里需要注意的是，如果你是引用的第三方 svg 然后添加自己的样式，如果该样式之前已经被第三方添加过，是不一定会覆盖第三方的设置的，也就是说自己设置的属性不一定会生效…例如下面的代码设置 colorB 就没生效： 1![](https://img.shields.io/cocoapods/v/Alamofire.svg?colorB=000000) 右半部分应该变成黑色，但是毫无效果的说： 其他 默认的徽标是居左排列的，如果需要居中排列需要使用 HTML 的方式来插入徽标，可参考 Kingfisher，代码和效果如下： 123456789101112131415161718192021222324&lt;p align="center"&gt; &lt;a href="https://travis-ci.org/onevcat/Kingfisher" &gt;![](https://img.shields.io/travis/onevcat/Kingfisher/master.svg)&lt;/a &gt; &lt;a href="https://github.com/Carthage/Carthage/" &gt;![](https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat)&lt;/a &gt; &lt;a href="https://swift.org/package-manager/" &gt;![](https://img.shields.io/badge/SPM-ready-orange.svg)&lt;/a &gt; &lt;a href="http://onevcat.github.io/Kingfisher/" &gt;![](https://img.shields.io/cocoapods/v/Kingfisher.svg?style=flat)&lt;/a &gt; &lt;a href="https://raw.githubusercontent.com/onevcat/Kingfisher/master/LICENSE" &gt;![](https://img.shields.io/cocoapods/l/Kingfisher.svg?style=flat)&lt;/a &gt; &lt;a href="http://onevcat.github.io/Kingfisher/" &gt;![](https://img.shields.io/cocoapods/p/Kingfisher.svg?style=flat)&lt;/a &gt; &lt;a href="https://codebeat.co/projects/github-com-onevcat-kingfisher" &gt;![codebeat badge](https://codebeat.co/assets/svg/badges/A-398b39-669406e9e1b136187b91af587d4092b0160370f271f66a651f444b990c2730e9.svg)&lt;/a &gt;&lt;/p&gt; 没了，🙄 再次提示：因为文中某些示例需要 GitHub 的 Markdown 环境支持，所以如果遇到阅读问题，比如某些 HTML 标签露了出来之类的，可以在 GitHub 查看，地址为 github.com/EyreFree/EF…。 再读一篇类似文章？ GitHub Wiki 页面的添加和设置 如有任何知识产权、版权问题或理论错误，还请指正。 https://juejin.im/post/5a32157c6fb9a0450b6667ac 转载请注明原作者及以上信息。]]></content>
      <categories>
        <category>markdown</category>
        <category>badge</category>
      </categories>
      <tags>
        <tag>归纳</tag>
        <tag>转载</tag>
        <tag>github</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30分钟学会反向Ajax]]></title>
    <url>%2Farchives%2Ffront-end%2Fnetwork-request%2Fajax%2F1514362414.html</url>
    <content type="text"><![CDATA[场景1：当有新邮件的时候，网页自动弹出提示信息而无需用户手动的刷新收件箱。 场景2：当用户的手机扫描完成页面中的二维码以后，页面会自动跳转。 场景3：在类似聊天室的环境中有任何人发言，所有登录用户都可以即时看见信息。 与传统的MVC模型请求必须从客户端发起由服务器响应相比，使用反向Ajax能够模拟服务器端主动向客户端推送事件从而提高用户体验。本文将分两个部分讨论反向Ajax技术，包括：Comet和WebSocket。文章旨在演示如何实现以上两种技术手段，Struts2或SpringMVC中的应用并未涉及。此外，Servlet的配置也采用注解的方式，相关知识大家可以参考其它资料。 一、Comet（最佳的兼容手段） Comet本质上则是这样的一种概念：能够从服务器端向客户端发送数据。在一个标准的 HTTP Ajax 请求中，数据是发送给服务器端的，反向 Ajax 以某些特定的方式来模拟发出一个 Ajax 请求，这样的话，服务器就可以尽可能快地向客户端发送事件。由于普通HTTP请求往往会伴随页面的跳转，而推送事件则需要浏览器停留在同一个页面或者框架下，因此Comet的实现只能够通过Ajax来完成。 它的实现过程如下：页面加载的时候随即向服务器发送一条Ajax请求，服务器端获取请求并将它保存在一个线程安全的容器中（通常为队列）。同时服务器端仍然可以正常响应其他请求。当需要推送的事件到来的时候，服务器遍历容器中的请求在返回应答后删除。于是所有停留在页面中的浏览器都会获得该应答，并再次发送Ajax请求，重复上述过程。 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;; %&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; &lt;head&gt; &lt;title&gt;WebSocket&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;static/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function() { connect(); $(&quot;#btn&quot;).click(function() { var value = $(&quot;#message&quot;).val(); $.ajax({ url : &quot;longpolling?method=onMessage&amp;msg=&quot; + value, cache : false, dataType : &quot;text&quot;, success : function(data) { } }); }); }); &lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #0000ff;&quot;&gt;function&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt; connect() { $.ajax({ url : &lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;longpolling?method=onOpen&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;, cache : &lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #0000ff;&quot;&gt;false&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;, dataType : &lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;text&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;, success : &lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #0000ff;&quot;&gt;function&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;(data) { connect(); alert(data); } }); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;LongPolling&lt;/h1&gt; &lt;input type=“text” id=“message” /&gt; &lt;input type=“button” id=“btn” value=“发送” /&gt; &lt;/body&gt; &lt;/html&gt; 我们注意到，由btn发送的请求其实并不需要获取应答。整个过程的关键是需要客户端始终让服务器保持connect()的请求。而服务器端首先需要支持这种异步的响应方式，幸运的是目前为止绝大部分的Servlet容器都已经提供了良好的支持。下面以Tomcat为例： package servlet; import java.io.IOException; import java.io.PrintWriter; import java.util.Queue; import java.util.concurrent.ConcurrentLinkedQueue; import javax.servlet.AsyncContext; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet(value=&quot;/longpolling&quot;, asyncSupported=true) public class Comet extends HttpServlet { private static final Queue&lt;AsyncContext&gt; CONNECTIONS = new ConcurrentLinkedQueue&lt;AsyncContext&gt;(); @Override &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;protected&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; doGet(HttpServletRequest req, HttpServletResponse resp) &lt;span style=&quot;color: #0000ff;&quot;&gt;throws&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; ServletException, IOException { String method &lt;/span&gt;= req.getParameter(&amp;quot;method&amp;quot;&lt;span style=&quot;color: #000000;&quot;&gt;); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (method.equals(&amp;quot;onOpen&amp;quot;&lt;span style=&quot;color: #000000;&quot;&gt;)) { onOpen(req, resp); } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;else&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;if&lt;/span&gt; (method.equals(&amp;quot;onMessage&amp;quot;&lt;span style=&quot;color: #000000;&quot;&gt;)) { onMessage(req, resp); } } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; onOpen(HttpServletRequest req, HttpServletResponse resp) &lt;span style=&quot;color: #0000ff;&quot;&gt;throws&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; ServletException, IOException { AsyncContext context &lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt; req.startAsync(); context.setTimeout(&lt;/span&gt;0&lt;span style=&quot;color: #000000;&quot;&gt;); CONNECTIONS.offer(context); } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; onMessage(HttpServletRequest req, HttpServletResponse resp) &lt;span style=&quot;color: #0000ff;&quot;&gt;throws&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; ServletException, IOException { String msg &lt;/span&gt;= req.getParameter(&amp;quot;msg&amp;quot;&lt;span style=&quot;color: #000000;&quot;&gt;); broadcast(msg); } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;synchronized&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; broadcast(String msg) { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (AsyncContext context : CONNECTIONS) { HttpServletResponse response &lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt; (HttpServletResponse) context.getResponse(); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;try&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; { PrintWriter out &lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt; response.getWriter(); out.print(msg); out.flush(); out.close(); context.complete(); CONNECTIONS.remove(context); } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;catch&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (IOException e) { e.printStackTrace(); } } } } ConcurrentLinkedQueue是Queue队列的一个线程安全实现，这里使用它来作为保存请求的容器。AsyncContext是Tomcat支持的异步环境，不同的服务器使用的对象也略有不同。Jetty支持的对象是Continuation。完成了广播的请求需要通过context.complete()将相关请求结束，并使用CONNECTIONS.remove(context)删除队列。 二、WebSocket（来自HTML5的支持） &nbsp;使用 HTTP 长轮询的 Comet 是可靠地实现反向 Ajax 的最佳方式，因为现在所有浏览器都提供了这方面的支持。 WebSockets 在 HTML5 中出现，是比 Comet 更新的反向 Ajax 技术。WebSockets 支持双向、全双工通信信道，而且许多浏览器（Firefox、Google Chrome 和 Safari）也支持它。连接通过 HTTP 请求（也称为 WebSockets 握手）和一些特殊的标头 (header)。连接一直处于激活状态，您可以用 JavaScript 编写和接收数据，正如您使用原始 TCP 套接字一样。 通过输入&nbsp;ws://&nbsp;或&nbsp;wss://（在 SSL 上）启动 WebSocket URL。如图： 首先：WebSockets并非在所有浏览器上都能获得良好的支持，显然IE又拖了后腿。因此当你打算使用这项技术之前必须考虑到用户的使用环境，如果你的项目面向的是互联网或者包括手机端用户，奉劝大家三思。 其次：WebSockets提供的请求区别于普通的HTTP请求，它是一种全双工通信且始终处于激活状态（如果你不去关闭它的话）。这就意味着你不用每次获得应答后再次向服务器发送请求，这样可以节约大量的资源。 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;; String ws = &quot;ws://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;; %&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; &lt;head&gt; &lt;title&gt;WebSocket&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;static/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function() { var websocket = null; if (&quot;WebSocket&quot; in window){ websocket = new WebSocket(&quot;&lt;%=ws%&gt;websocket&quot;); } else { alert(&quot;not support&quot;); } websocket.onopen = function(evt) { } websocket.onmessage &lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;background-color: #f5f5f5; color: #0000ff;&quot;&gt;function&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;(evt) { alert(evt.data); } websocket.onclose &lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;background-color: #f5f5f5; color: #0000ff;&quot;&gt;function&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;(evt) { } $(&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;#btn&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;).click(&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #0000ff;&quot;&gt;function&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;() { &lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #0000ff;&quot;&gt;var&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt; text &lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt; $(&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;#message&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;).val(); websocket.send(text); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;WebSocket&lt;/h1&gt; &lt;input type=“text” id=“message” /&gt; &lt;input type=“button” id=“btn” value=“发送”/&gt; &lt;/body&gt; &lt;/html&gt; JQuery对WebSocket还未提供更良好的支持，因此我们必须使用Javascript来编写部分代码（好在并不复杂）。并且打部分常见的服务器都可以支持ws请求，以Tomcat为例。在6.0版本中WebSocketServlet对象已经被标注为@java.lang.Deprecated，7.0以后的版本支持jsr365提供的实现，因此你必须使用注解来完成相关配置。 package servlet; import java.io.IOException; import java.util.Queue; import java.util.concurrent.ConcurrentLinkedQueue; import javax.websocket.OnClose; import javax.websocket.OnMessage; import javax.websocket.OnOpen; import javax.websocket.Session; import javax.websocket.server.ServerEndpoint; @ServerEndpoint(&quot;/websocket&quot;) public class WebSocket { private static final Queue&lt;WebSocket&gt; CONNECTIONS = new ConcurrentLinkedQueue&lt;WebSocket&gt;(); private Session session; @OnOpen &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; onOpen(Session session) { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;this&lt;/span&gt;.session =&lt;span style=&quot;color: #000000;&quot;&gt; session; CONNECTIONS.offer(&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;this&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;); } @OnMessage &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; onMessage(String message) { broadcast(message); } @OnClose &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; onClose() { CONNECTIONS.remove(&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;this&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;); } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;synchronized&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; broadcast(String msg) { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (WebSocket point : CONNECTIONS) { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;try&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; { point.session.getBasicRemote().sendText(msg); } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;catch&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (IOException e) { CONNECTIONS.remove(point); &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;try&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; { point.session.close(); } &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;catch&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; (IOException e1) { } } } } } 三、总结（从请求到推送） 在传统通信方案中，如果系统 A 需要系统 B 中的信息，它会向系统 B 发送一个请求。系统 B 将处理请求，而系统 A 会等待响应。处理完成后，会将响应发送回系统 A。在同步&nbsp;通信模式下，资源使用效率比较低，这是因为等待响应时会浪费处理时间。 在异步&nbsp;模式下，系统 A 将订阅它想从系统 B 中获取的信息。然后，系统 A 可以向系统 B 发送一个通知，也可以立即返回信息，与此同时，系统 A 可以处理其他事务。这个步骤是可选的。在事件驱动应用程序中，通常不必请求其他系统发送事件，因为您不知道这些事件是什么。在系统 B 发布响应之后，系统 A 会立即收到该响应。 Web 框架过去通常依赖传统 “请求-响应” 模式，该模式会导致页面刷新。随着 Ajax、Reverse Ajax 以及&nbsp;WebSocket&nbsp;的出现，现在可以将事件驱动架构的概念轻松应用于 Web，获得去耦合、可伸缩性和反应性 (reactivity) 等好处。更良好的用户体验也会带来新的商业契机。 原文链接 https://www.cnblogs.com/learnhow/p/5708364.html]]></content>
      <categories>
        <category>前端</category>
        <category>网络请求</category>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>接口</tag>
        <tag>API</tag>
        <tag>转载</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES7标准-fetch请求封装]]></title>
    <url>%2Farchives%2Ffront-end%2Fnetwork-request%2Ffetch%2F1512127302.html</url>
    <content type="text"><![CDATA[原文地址：http://blog.csdn.net/BingHongChaZuoAn/article/details/52851980 作为一个程序猿，一定要养成一个爱学习的好习惯，因为程序员是一个终身学习的职业，要时刻把Live and learn作为一种信仰。I can’t change the world，only change myself。 闲话少说，言归正传，今天跟大家分享下我自己封装的延用ES7标准的 fetch请求，不好之处忘大家见谅。 首先是 Header model类型，配置文件 header.js。 let Header = { 'Accept': 'application/json', //json形式 'Content-Type': 'application/json' } module.exports = Header; netTools.js export default { /*检查对象是否为空*/ isEmpty(obj){ for (var r in obj){return false;} return true; }, /*把String转化成对象*/ toObj(obj){ ​ if(typeof obj === 'object'){ ​ return obj; ​ }else{ ​ return eval('('+obj+')'); ​ } }, /*判断对象是否为空*/ isNull(obj){ ​ return (!obj &amp;&amp; typeof(obj)!=&quot;undefined&quot; &amp;&amp; obj!=0)?true:false; }, } NetUtil.js 'use strict'; import React, { Component} from 'react'; var Header = require('./header'); class NetUitl extends Component { constructor(props){ ​ super(props); ​ this.state ={ ​ headers:Header,//选中的位置 ​ }; } /** *url :请求地址 *data:参数(Json对象) *callback:回调函数 */ static async fetchAsync (hostUrl, methodUrl, method, data, callback) { let fetchOptions; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(method === &lt;span class=&quot;hljs-string&quot;&gt;'get'&lt;/span&gt;){ fetchOptions = { method: &lt;span class=&quot;hljs-string&quot;&gt;'GET'&lt;/span&gt;, mode: &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;cors&amp;quot;&lt;/span&gt;, headers: Header, credentials: &lt;span class=&quot;hljs-string&quot;&gt;'include'&lt;/span&gt;, }; } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(method === &lt;span class=&quot;hljs-string&quot;&gt;'post'&lt;/span&gt;){ fetchOptions = { method: &lt;span class=&quot;hljs-string&quot;&gt;'POST'&lt;/span&gt;, mode: &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;cors&amp;quot;&lt;/span&gt;, headers: Header, credentials: &lt;span class=&quot;hljs-string&quot;&gt;'include'&lt;/span&gt;, body: JSON.stringify(data), }; } // alert(JSON.stringify(fetchOptions)); let LOGIN_REQUEST= this.transform(hostUrl,methodUrl,data); LOGIN_REQUEST = encodeURI(LOGIN_REQUEST); //由于我们的服务器有点问题，只支持 url 拼接参数的方式传值，所以只能这么写了 try { ​ let response = await fetch(LOGIN_REQUEST, fetchOptions); ​ let responseJson = await response.json(); ​ // alert(JSON.stringify(responseJson)); ​ callback(responseJson); } catch(error) { ​ console.error(error); } } static addHeaders(obj) { ​ for(var r in obj){ ​ eval(“Header.”+r+&quot;=obj.&quot;+r); ​ } ​ return Header; } static clearHeader(){ ​ Header={}; ​ return Header; } static changeHeader(key,value) { ​ for(var r in Header){ ​ if(r==key){ ​ eval(“Header.”+key+&quot;=&quot;+JSON.stringify(value)); ​ return Header; ​ } ​ } ​ console.log(‘not find header:’+key); } static deleteHeader(key) { ​ eval(“Header.”+key+&quot;=undefined&quot;); ​ return Header; } /** 对象解析变换，目前只支持简单对象变换。 */ static transform(hostUrl, methodUrl, obj){ let responseUrl = hostUrl+ methodUrl+’?’; for(var key in obj){//用 javascript 的 for/in 循环遍历对象的属性 ​ responseUrl += key+&quot;=&quot;+obj[key]+&quot;&amp;&quot;; } // alert(responseUrl); let index = responseUrl.lastIndexOf(’&amp;’); responseUrl = responseUrl.substring(0,index); return responseUrl; } } module.exports = NetUitl;``` http.js let NetUitl = require('./NetUtil'); import Tools from './netTools'; function fetchAction(...props) { this.hostUrl = props.shift(1); this.methodUrl = props.shift(1); this.method = props.shift(1); this.header = props.shift(1); this.params = props.shift(1); this.callback = props.shift(1); // this.failureDo = props.shift(1); // this.finallyDo = props.shift(1); // alert(!Tools.isEmpty(this.header)); if(!Tools.isEmpty(this.header)){ ​ NetUitl.addHeaders(this.header); } NetUitl.fetchAsync(this.hostUrl, this.methodUrl,this.method, this.params, ​ (code, msg, data)=&gt;{this.callback(code, msg, data);}, ​ ); } export default { post(hostUrl,methodUrl, params,callback){ ​ fetchAction(hostUrl,methodUrl, 'post',null, params,callback); }, postWithHeader(hostUrl,methodUrl, headers, params,callback){ ​ fetchAction(hostUrl,methodUrl, 'post', headers, params,callback); }, get(hostUrl,methodUrl, params,callback){ ​ fetchAction(hostUrl,methodUrl, 'get', null, params,callback); }, getWithHeader(hostUrl,methodUrl, headers, params,callback){ ​ fetchAction(hostUrl,methodUrl,'get', headers, params,callback); }, } API.js onst HOSTURL= 'http://xxxx'; import Http from './http'; export default { getDetail(params,callback) { ​ let methodUrl = 'xxxx'; ​ let header = {xxx:xxx}; ​ Http.post(HOSTURL,methodUrl, params,callback); ​ //Http.post(HOSTURL,methodUrl, header ,params,callback); ​ //Http.get(HOSTURL,methodUrl, params,callback); ​ //Http.get(HOSTURL,methodUrl, header ,params,callback); }, } 上述已经封装完成。接下来，看看如何调用吧。 let params={'kw':'w'}; Api.getDetail(params,(response)=&gt;{ alert(JSON.stringify(response)); }, ); “` 以上基本完成了fetch请求的封装，包括动态添加、删除、修改header。允许携带cookie。之所以没有让fetch可以动态设置cookie，是因为fetch请求本身不太完善，需要做一些设置，git上有一套方案，不过好像用了他的，header就不能动态设置了，最近比较忙，也没时间深入研究，暂时就这样吧，以后深入研究下人家的东西，再慢慢优化。 作者：_左左 来源：CSDN 原文：https://blog.csdn.net/BingHongChaZuoAn/article/details/52851980 版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
      <categories>
        <category>前端</category>
        <category>网络请求</category>
        <category>fetch</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMAScript</tag>
        <tag>接口</tag>
        <tag>API</tag>
        <tag>转载</tag>
        <tag>ES7</tag>
        <tag>fetch</tag>
      </tags>
  </entry>
</search>
